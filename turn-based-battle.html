<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>对战系统</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&family=ZCOOL+XiaoWei&display=swap" rel="stylesheet">
    <style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    user-select: none;
}

body {
    font-family: 'ZCOOL XiaoWei', 'Microsoft YaHei', sans-serif;
    background-color: #000;
    color: #fff;
    overflow: hidden;
    margin: 0;  /* 确保没有margin */
    padding: 0;  /* 确保没有padding */
    display: flex;
    justify-content: center;
    align-items: flex-start;  /* 从center改为flex-start，让内容从顶部开始 */
    width: 100vw;
    height: 100vh;
}

.game-container {
    /* 通过JS动态设置宽高，保持4:3比例 */
    position: relative;
    display: flex;
    flex-direction: column;
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    margin-top: 0;  /* 确保紧贴顶部 */
    overflow: hidden;  /* 防止子元素溢出 */
}

/* 背景毛玻璃层 */
.game-container::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: inherit;
    background-size: inherit;
    background-position: inherit;
    filter: blur(3px);
    z-index: 0;
}

/* 背景遮罩层（让毛玻璃效果更柔和） */
.game-container::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.15);
    z-index: 1;
}

.battle-scene {
    flex: 1;
    position: relative;
    display: flex;
    justify-content: space-between;
    align-items: flex-end;
    padding-bottom: clamp(60px, 12vw, 120px);
}

/* 状态区样式 - 使用clamp适配不同屏幕 */
.player-status-area {
    position: absolute;
    top: clamp(5px, 1vw, 15px);
    left: clamp(5px, 1vw, 15px);
    width: clamp(130px, 20vw, 240px);
    height: auto;
    background-color: rgba(0, 0, 0, 0.85);
    border-radius: clamp(4px, 0.5vw, 8px);
    padding: clamp(6px, 1vw, 12px);
    z-index: 5;
    border: 1px solid rgba(255, 255, 255, 0.3);
    box-shadow: 0 0 8px rgba(0, 0, 0, 0.6);
}

/* 名字行：包含名字和挑衅状态 */
.name-row {
    display: flex;
    align-items: center;
    justify-content: flex-start;
    gap: clamp(6px, 1vw, 12px);
    margin-bottom: clamp(3px, 0.5vw, 6px);
    border-bottom: 1px solid rgba(255, 204, 0, 0.3);
    padding-bottom: clamp(2px, 0.3vw, 5px);
}

.character-name {
    font-size: clamp(14px, 1.6vw, 20px);
    font-weight: bold;
    color: #ffcc00;
    text-align: left;
    font-family: 'Ma Shan Zheng', cursive;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
}

.enemy-status-area {
    position: absolute;
    top: clamp(5px, 1vw, 15px);
    right: clamp(5px, 1vw, 15px);
    width: clamp(130px, 20vw, 240px);
    height: auto;
    background-color: rgba(0, 0, 0, 0.85);
    border-radius: clamp(4px, 0.5vw, 8px);
    padding: clamp(6px, 1vw, 12px);
    z-index: 5;
    border: 1px solid rgba(255, 255, 255, 0.3);
    box-shadow: 0 0 8px rgba(0, 0, 0, 0.6);
}

/* HP和气同一行显示 */
.stats-row {
    display: flex;
    align-items: center;
    gap: clamp(6px, 1vw, 12px);
}

.health-container {
    flex: 1;
    display: flex;
    align-items: center;
    position: relative;
}

.health-bar {
    flex: 1;
    height: clamp(16px, 2.2vw, 26px);
    background-color: #333;
    border-radius: clamp(2px, 0.3vw, 4px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    position: relative;
    overflow: visible;
}

.health-fill {
    position: absolute;
    left: 0;
    top: 0;
    height: 100%;
    background: linear-gradient(to right, #ff0043, #ff6a00);
    width: 100%;
    transition: width 0.5s cubic-bezier(.4,2,.6,1);
    border-radius: clamp(2px, 0.3vw, 4px) 0 0 clamp(2px, 0.3vw, 4px);
}

/* HP数字显示在血条内部 */
.health-text {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    font-size: clamp(10px, 1.2vw, 14px);
    color: #fff;
    text-align: center;
    font-weight: bold;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8), 
                 -1px -1px 2px rgba(0, 0, 0, 0.8),
                 1px -1px 2px rgba(0, 0, 0, 0.8),
                 -1px 1px 2px rgba(0, 0, 0, 0.8);
    white-space: nowrap;
    z-index: 2;
}

/* 气值显示在右边 */
.energy-display {
    display: flex;
    align-items: center;
    flex-shrink: 0;
}

.energy-value {
    font-size: clamp(11px, 1.3vw, 16px);
    color: #ffcc00;
    font-weight: bold;
    white-space: nowrap;
}

.energy-icon {
    display: none;
}

/* 挑衅状态显示样式 - 显示在名字右侧 */
.taunt-status {
    display: none;
    padding: clamp(1px, 0.3vw, 3px) clamp(4px, 0.6vw, 8px);
    background: linear-gradient(135deg, rgba(255, 60, 60, 0.9), rgba(180, 20, 20, 0.95));
    border-radius: clamp(2px, 0.3vw, 4px);
    font-size: clamp(9px, 1vw, 12px);
    font-weight: bold;
    color: #fff;
    text-align: center;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
    animation: taunt-pulse 1s ease-in-out infinite;
    border: 1px solid rgba(255, 100, 100, 0.6);
    white-space: nowrap;
    flex-shrink: 0;
}

.taunt-status.active {
    display: inline-block;
}

@keyframes taunt-pulse {
    0% { opacity: 0.8; transform: scale(1); }
    50% { opacity: 1; transform: scale(1.02); }
    100% { opacity: 0.8; transform: scale(1); }
}

/* 回合指示器 - 可点击显示日志 */
.turn-indicator {
    position: absolute;
    top: 0;
    left: 50%;
    transform: translateX(-50%);
    background-color: rgba(0, 0, 0, 0.85);
    padding: clamp(6px, 0.8vw, 12px) clamp(12px, 2vw, 25px);
    border-radius: 0 0 clamp(8px, 1.2vw, 15px) clamp(8px, 1.2vw, 15px);
    z-index: 20;
    font-size: clamp(14px, 1.8vw, 22px);
    font-weight: bold;
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-top: none;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.6);
    font-family: 'Ma Shan Zheng', cursive;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
    white-space: nowrap;
    cursor: pointer;
    transition: background-color 0.2s;
}

.turn-indicator:hover {
    background-color: rgba(30, 30, 30, 0.95);
}

.turn-indicator {
    display: flex;
    flex-direction: column;
    align-items: center;
}

.turn-indicator::after {
    content: '▼';
    font-size: clamp(8px, 1vw, 12px);
    opacity: 0.7;
    margin-top: clamp(2px, 0.3vw, 4px);
}

/* 日志下拉框 */
.log-dropdown {
    display: none;
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    width: clamp(280px, 50vw, 550px);
    max-height: 35vh;
    background-color: rgba(0, 0, 0, 0.75);
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 0 0 clamp(6px, 1vw, 12px) clamp(6px, 1vw, 12px);
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
    overflow-y: auto;
    z-index: 19;
    padding: clamp(8px, 1.2vw, 15px);
}

.log-dropdown.active {
    display: block;
}

.log-dropdown p {
    margin: clamp(3px, 0.5vw, 6px) 0;
    padding: clamp(3px, 0.5vw, 6px) 0;
    font-size: clamp(13px, 1.5vw, 18px);
    color: #fff;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    line-height: 1.5;
}

.log-dropdown p:last-child {
    border-bottom: none;
}

/* 命令区域 - 水墨风格 */
.command-area {
    position: absolute;
    bottom: 30px;
    left: 50%;
    transform: translateX(-50%);
    width: 90%;
    max-width: 800px;
    background-color: rgba(0, 0, 0, 0.7);
    border-radius: 10px;
    padding: 15px;
    z-index: 10;
    border: 1px solid rgba(255, 255, 255, 0.3);
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.6);
}

.command-label {
    margin-bottom: 10px;
    font-size: 24px;
    color: #eee;
    text-align: center;
    font-family: 'Ma Shan Zheng', cursive;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
}

.command-buttons {
    display: flex;
    justify-content: space-around;
    gap: 10px;
}

/* 指令按钮浮动样式 - 60%屏幕宽度，靠右放置 */
.command-buttons-floating {
    position: absolute;
    right: 0;
    bottom: 0;
    display: flex;
    flex-direction: row;
    gap: clamp(3px, 0.5vw, 8px);
    padding: clamp(4px, 0.6vw, 10px);
    z-index: 10;
    justify-content: flex-end;
    flex-wrap: nowrap;
    width: 60%;
    max-width: 60vw;
}

.command-btn {
    flex: 1 1 0;
    min-width: 0;
    /* 使用aspect-ratio确保高度始终是宽度的2倍 */
    aspect-ratio: 1 / 2;
    height: auto;
    margin: 0;
    padding: clamp(4px, 0.6vw, 10px);
    border-radius: clamp(4px, 0.6vw, 8px);
    background: #111 !important;
    color: #fff !important;
    border: 1px solid #333;
    box-shadow: 1px 1px 4px rgba(0,0,0,0.15);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s;
    position: relative;
    overflow: visible;
}

.command-btn::before {
    content: '';
    position: absolute;
    top: -2px;
    left: -2px;
    right: -2px;
    bottom: -2px;
    background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.1), transparent);
    z-index: -1;
    border-radius: clamp(4px, 0.6vw, 8px);
}

.command-btn:hover:not(.disabled) {
    background: #222 !important;
    transform: translateY(-2px);
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
    border-color: #666;
}

.command-btn:active:not(.disabled) {
    background: #333 !important;
    transform: translateY(0);
}

.command-btn.selected {
    background: linear-gradient(135deg, #1a3a75, #0c1f3e) !important;
    border-color: #3a6cbf;
    box-shadow: 0 0 15px rgba(58, 108, 191, 0.6);
}

/* 逃跑按钮特殊样式 */
.command-btn.escape-btn {
    background: linear-gradient(135deg, #4a1a1a, #2a0a0a) !important;
    border-color: #733;
}

.command-btn.escape-btn:hover:not(.disabled) {
    background: linear-gradient(135deg, #5a2a2a, #3a1a1a) !important;
    border-color: #944;
}

.command-btn.disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

/* 键位提示自适应 */
.command-btn .key-hint {
    position: absolute;
    top: clamp(2px, 0.3vw, 5px);
    left: 50%;
    transform: translateX(-50%);
    background-color: rgba(0, 0, 0, 0.7);
    color: #fff;
    font-size: clamp(8px, 1vw, 12px);
    padding: clamp(1px, 0.2vw, 3px) clamp(2px, 0.4vw, 5px);
    border-radius: clamp(2px, 0.2vw, 4px);
    line-height: 1;
}

/* 按钮名称 - 纵向排列 */
.command-btn .btn-name {
    display: block !important;
    font-size: clamp(14px, 2vw, 22px) !important;
    font-weight: bold !important;
    font-family: 'Ma Shan Zheng', cursive !important;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5) !important;
    text-align: center !important;
    line-height: 1.2 !important;
    margin-top: clamp(12px, 2vw, 20px) !important;
    writing-mode: vertical-rl !important;
    text-orientation: upright !important;
    letter-spacing: 0.15em !important;
    white-space: nowrap !important;
}

/* 战斗日志 - 隐藏（改为下拉框显示） */
.battle-log {
    display: none;
}

/* 确认弹窗 - 手机优化 */
.modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    z-index: 100;
    align-items: center;
    justify-content: center;
    padding: 15px;
}

.modal-content {
    width: clamp(240px, 60vw, 320px);
    max-width: 85vw;
    border-radius: clamp(4px, 1vw, 8px);
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
    color: #fff;
    position: relative;
    border: 2px solid #553c28;
    overflow: hidden;
}

.modal-header {
    padding: clamp(6px, 2vw, 12px);
    background-color: rgba(0, 0, 0, 0.6);
    font-size: clamp(14px, 3.2vw, 20px);
    font-weight: bold;
    text-align: center;
    border-bottom: 1px solid rgba(255, 255, 255, 0.2);
    font-family: 'Ma Shan Zheng', cursive;
    /* 添加黑色描边效果 */
    text-shadow: 
    -1px -1px 1px #000,
    1px -1px 1px #000,
    -1px 1px 1px #000,
    1px 1px 1px #000,
    2px 2px 3px rgba(0, 0, 0, 0.8);
}

.modal-body {
    padding: clamp(8px, 2.5vw, 15px);
    font-size: clamp(12px, 2.8vw, 16px);
    text-align: center;
    line-height: 1.4;
    /* 添加与按钮相同的字体样式 */
    font-family: 'Ma Shan Zheng', cursive;
    font-weight: bold;
    color: #fff;
    /* 黑色描边效果 */
    text-shadow: 
        -1px -1px 1px #000,
        1px -1px 1px #000,
        -1px 1px 1px #000,
        1px 1px 1px #000,
        2px 2px 3px rgba(0, 0, 0, 0.8);
}

.modal-footer {
    padding: clamp(6px, 2vw, 12px);
    display: flex;
    justify-content: space-around;
    border-top: 1px solid rgba(255, 255, 255, 0.2);
    gap: clamp(6px, 1.5vw, 12px);
}

.modal-footer button {
    padding: clamp(4px, 1.5vw, 8px) clamp(10px, 3vw, 16px);
    border: none;
    border-radius: clamp(3px, 0.8vw, 6px);
    cursor: pointer;
    font-size: clamp(11px, 2.5vw, 14px);
    font-family: 'ZCOOL XiaoWei', sans-serif;
    transition: all 0.3s;
    flex: 1;
    min-height: clamp(24px, 5vw, 36px);
}

#confirm-action {
    background: linear-gradient(to bottom, #5c3b1c, #34210f);
    color: white;
    border: 1px solid #7c5a3d;
}

#confirm-action:hover {
    background: linear-gradient(to bottom, #6c4a2b, #3e2914);
    transform: translateY(-2px);
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
}

#cancel-action {
    background: linear-gradient(to bottom, #444, #222);
    color: #ddd;
    border: 1px solid #666;
}

#cancel-action:hover {
    background: linear-gradient(to bottom, #555, #333);
    transform: translateY(-2px);
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
}

/* 动画效果 */
@keyframes attack {
    0% { transform: translateX(0); }
    25% { transform: translateX(40px); }
    50% { transform: translateX(0); }
    100% { transform: translateX(0); }
}

@keyframes enemy-attack {
    0% { transform: translateX(0); }
    25% { transform: translateX(-40px); }
    50% { transform: translateX(0); }
    100% { transform: translateX(0); }
}

@keyframes hit {
    0% { filter: brightness(1); }
    25% { filter: brightness(3) saturate(2); }
    50% { filter: brightness(1); }
    100% { filter: brightness(1); }
}

@keyframes defend {
    0% { filter: brightness(1); }
    50% { filter: brightness(1.5) hue-rotate(120deg); }
    100% { filter: brightness(1); }
}

@keyframes special {
    0% { filter: brightness(1); }
    25% { filter: brightness(2) saturate(2) hue-rotate(270deg); }
    50% { filter: brightness(1.5) saturate(1.5) hue-rotate(180deg); }
    75% { filter: brightness(2) saturate(2) hue-rotate(90deg); }
    100% { filter: brightness(1); }
}

.player-attack {
    animation: attack 0.6s ease;
}

.enemy-attack {
    animation: enemy-attack 0.6s ease;
}

.player-hit {
    animation: hit 0.6s ease;
}

.enemy-hit {
    animation: hit 0.6s ease;
}

.player-defend {
    animation: defend 1s ease;
}

.enemy-defend {
    animation: defend 1s ease;
}

.player-special {
    animation: special 1s ease;
}

.enemy-special {
    animation: special 1s ease;
}

/* 画面晃动动画 */
@keyframes shake {
  0% { transform: translate(0, 0); }
  20% { transform: translate(-10px, 0); }
  40% { transform: translate(10px, 0); }
  60% { transform: translate(-10px, 0); }
  80% { transform: translate(10px, 0); }
  100% { transform: translate(0, 0); }
}
.shake {
  animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both;
}

/* 受击红色边缘高亮动画 */
@keyframes damage-flash {
  0% { box-shadow: 0 0 0 0 rgba(255,0,0,0.7); }
  30% { box-shadow: 0 0 0 20px rgba(255,0,0,0.5); }
  60% { box-shadow: 0 0 0 40px rgba(255,0,0,0.2); }
  100% { box-shadow: 0 0 0 0 rgba(255,0,0,0); }
}
.damage-flash {
  animation: damage-flash 0.5s;
}

/* 主角图层 */
.player-portrait-layer {
    position: absolute;
    left: 0;
    bottom: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 3;
    background: none;
    background-position: center bottom;
    background-repeat: no-repeat;
    background-size: contain;
    transition: background-image 0.3s, filter 0.2s ease;
    /* 使用CSS变量控制描边颜色，默认白色 */
    --glow-color: 255, 255, 255;
    --glow-intensity: 0.8;
    filter: drop-shadow(0 0 1px rgba(var(--glow-color), var(--glow-intensity)))
            drop-shadow(0 0 2px rgba(var(--glow-color), calc(var(--glow-intensity) * 0.6)))
            drop-shadow(0 0 3px rgba(var(--glow-color), calc(var(--glow-intensity) * 0.4)));
}

.player-portrait-layer.shake {
    animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both;
}

/* NPC图层 */
.npc-portrait-layer {
    position: absolute;
    left: 0;
    bottom: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 3;
    background: none;
    background-position: center bottom;
    background-repeat: no-repeat;
    background-size: contain;
    transition: background-image 0.3s, filter 0.2s ease;
    /* 使用CSS变量控制描边颜色，默认白色 */
    --glow-color: 255, 255, 255;
    --glow-intensity: 0.8;
    filter: drop-shadow(0 0 1px rgba(var(--glow-color), var(--glow-intensity)))
            drop-shadow(0 0 2px rgba(var(--glow-color), calc(var(--glow-intensity) * 0.6)))
            drop-shadow(0 0 3px rgba(var(--glow-color), calc(var(--glow-intensity) * 0.4)));
}

.npc-portrait-layer.shake {
    animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both;
}

/* 攻击描边效果 - 黄色（轻攻击） */
.player-portrait-layer.glow-yellow,
.npc-portrait-layer.glow-yellow {
    --glow-color: 255, 215, 0;
    --glow-intensity: 1;
    filter: drop-shadow(0 0 1px rgba(var(--glow-color), var(--glow-intensity)))
            drop-shadow(0 0 2px rgba(var(--glow-color), calc(var(--glow-intensity) * 0.6)))
            drop-shadow(0 0 3px rgba(var(--glow-color), calc(var(--glow-intensity) * 0.4)));
}

/* 攻击描边效果 - 橙色（重攻击） */
.player-portrait-layer.glow-orange,
.npc-portrait-layer.glow-orange {
    --glow-color: 255, 140, 0;
    --glow-intensity: 1;
    filter: drop-shadow(0 0 1px rgba(var(--glow-color), var(--glow-intensity)))
            drop-shadow(0 0 2px rgba(var(--glow-color), calc(var(--glow-intensity) * 0.6)))
            drop-shadow(0 0 3px rgba(var(--glow-color), calc(var(--glow-intensity) * 0.4)));
}

/* 攻击描边效果 - 红色（绝招） */
.player-portrait-layer.glow-red,
.npc-portrait-layer.glow-red {
    --glow-color: 255, 48, 48;
    --glow-intensity: 1;
    filter: drop-shadow(0 0 1px rgba(var(--glow-color), var(--glow-intensity)))
            drop-shadow(0 0 2px rgba(var(--glow-color), calc(var(--glow-intensity) * 0.6)))
            drop-shadow(0 0 3px rgba(var(--glow-color), calc(var(--glow-intensity) * 0.4)));
}

.screen-flash {
    position: fixed;
    left: 0; top: 0; right: 0; bottom: 0;
    width: 100vw;
    height: 100vh;
    pointer-events: none;
    z-index: 1000;
    opacity: 0;
    background: rgba(255,0,0,0.3);
    box-shadow: 0 0 0 20px rgba(255,0,0,0.5), 0 0 60px 40px rgba(255,0,0,0.2) inset;
    transition: opacity 0.2s;
}

.screen-flash.active {
    opacity: 1;
    transition: opacity 0.1s;
}

#restart-game {
    background: linear-gradient(to bottom, #5c3b1c, #34210f);
    color: white;
    border: 1px solid #7c5a3d;
    padding: clamp(6px, 2vw, 12px) clamp(20px, 4vw, 32px);
    border-radius: clamp(3px, 0.8vw, 6px);
    cursor: pointer;
    font-size: clamp(12px, 2.8vw, 16px);
    font-family: 'Ma Shan Zheng', cursive;
    transition: all 0.3s;
    width: 100%;
    min-height: clamp(28px, 6vw, 40px);
}

#restart-game:hover {
    background: linear-gradient(to bottom, #6c4a2b, #3e2914);
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
}

/* 移动端优化 */
@media (max-width: 900px) {
    /* .command-buttons-floating {
        width: 70vw;
        min-width: 260px;
        gap: clamp(2px, 0.8vw, 6px);
        padding: clamp(2px, 0.4vw, 6px) 0 0 clamp(2px, 0.4vw, 6px);
    } */
    
    .command-btn .btn-name {
        font-size: clamp(0.8rem, 2.8vw, 1.1rem);
    }
    
    .command-btn .key-hint {
        font-size: clamp(0.6rem, 1.8vw, 0.9rem);
    }
}

@media (max-width: 600px) {
    /* .command-buttons-floating {
        width: 85vw;
        min-width: 240px;
        gap: clamp(1px, 0.5vw, 4px);
        padding: clamp(1px, 0.3vw, 4px) 0 0 clamp(1px, 0.3vw, 4px);
        flex-direction: row;
    } */
    
    .command-btn .btn-name {
        font-size: clamp(0.7rem, 3vw, 1rem);
    }
    
    .command-btn .key-hint {
        font-size: clamp(0.5rem, 2vw, 0.8rem);
    }
}

/* 超大屏幕优化 */
@media (min-width: 1400px) {
    /* .command-buttons-floating {
        width: 45vw;
        max-width: 700px;
    } */
    
    .command-btn .btn-name {
        font-size: clamp(1.2rem, 1.8vw, 1.6rem);
    }
}

/* 超小屏幕优化 */
@media (max-width: 480px) {
    /* .command-buttons-floating {
        width: 95vw;
        min-width: 200px;
        gap: clamp(1px, 0.2vw, 2px);
        padding: 2px 0 0 2px;
        flex-direction: row;
    } */
    
    .command-btn {
        padding: clamp(0.2vw, 0.8vw, 1vw) clamp(0.1vw, 0.4vw, 0.6vw);
    }
    
    .command-btn .btn-name {
        font-size: clamp(0.6rem, 3.5vw, 0.9rem);
    }
    
    .command-btn .key-hint {
        font-size: clamp(0.4rem, 2.8vw, 0.7rem);
        padding: clamp(0.5px, 0.1vw, 2px) clamp(2px, 0.3vw, 4px);
    }
}

/* 横屏手机优化 */
@media (max-width: 900px) and (orientation: landscape) {
    .battle-scene {
        padding-bottom: clamp(60px, 10vw, 100px);
    }
    
    .turn-indicator {
        top: 0;
    }
}

/* 统一的弹窗按钮风格 */
.modal-actions {
    display: flex;
    gap: clamp(8px, 2vw, 14px);
    justify-content: center;
    padding: clamp(8px, 2vw, 14px);
    background: rgba(0,0,0,0.4);
    border-top: 1px solid rgba(255,255,255,0.18);
}

/* 道具弹窗样式 - 全屏覆盖game-container，紧凑布局确保4个道具同屏显示 */
#item-modal {
    position: absolute !important;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.9);
    z-index: 100;
    display: none;
    align-items: center;
    justify-content: center;
    padding: 0;
}

.item-modal-content {
    width: 100%;
    height: 100%;
    max-width: 100%;
    max-height: 100%;
    border-radius: 0;
    box-shadow: none;
    color: #fff;
    position: relative;
    border: none;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    background-color: rgba(20, 15, 10, 0.98);
    background-size: cover;
    background-position: center;
}

.item-modal-header {
    padding: 1.5vh 2vw;
    background-color: rgba(0, 0, 0, 0.6);
    font-size: clamp(0.9rem, 2.5vw, 1.4rem);
    font-weight: bold;
    text-align: center;
    border-bottom: 1px solid rgba(255, 255, 255, 0.25);
    font-family: 'Ma Shan Zheng', cursive;
    text-shadow:
        -1px -1px 1px #000,
        1px -1px 1px #000,
        -1px 1px 1px #000,
        1px 1px 1px #000,
        2px 2px 3px rgba(0, 0, 0, 0.8);
    flex-shrink: 0;
}

.item-list {
    padding: 1.5vh 3vw;
    display: flex;
    flex-direction: column;
    gap: 1.5vh;
    flex: 1;
    overflow: hidden;
    justify-content: space-evenly;
}

.item-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 1.2vh 2.5vw;
    background: rgba(0, 0, 0, 0.6);
    border-radius: 0.6vw;
    border: 1px solid rgba(255, 255, 255, 0.2);
    transition: all 0.15s ease;
    flex: 1;
    max-height: 16vh;
    min-height: 0;
}

.item-row:hover {
    background: rgba(60, 50, 30, 0.7);
    border-color: rgba(255, 200, 100, 0.5);
}

.item-row.disabled {
    opacity: 0.5;
    pointer-events: none;
}

.item-info {
    display: flex;
    flex-direction: column;
    gap: 0.3vh;
    flex: 1;
    min-width: 0;
}

.item-name {
    font-size: clamp(0.85rem, 2.2vw, 1.2rem);
    font-weight: bold;
    font-family: 'Ma Shan Zheng', cursive;
    color: #ffd700;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.item-desc {
    font-size: clamp(0.6rem, 1.5vw, 0.85rem);
    color: #bbb;
    font-family: 'ZCOOL XiaoWei', sans-serif;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.item-count {
    font-size: clamp(0.8rem, 2vw, 1.1rem);
    color: #88ff88;
    font-weight: bold;
    min-width: 5vw;
    text-align: center;
    margin: 0 1.5vw;
    flex-shrink: 0;
}

.item-count.empty {
    color: #ff6666;
}

.item-use-btn {
    padding: 0.8vh 2.5vw;
    background: linear-gradient(135deg, #5c3b1c, #34210f);
    color: #fff;
    border: 1px solid #7c5a3d;
    border-radius: 0.5vw;
    font-size: clamp(0.75rem, 1.8vw, 1rem);
    font-family: 'Ma Shan Zheng', cursive;
    cursor: pointer;
    transition: all 0.15s ease;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.6);
    white-space: nowrap;
    flex-shrink: 0;
}

.item-use-btn:hover:not(:disabled) {
    background: linear-gradient(135deg, #7c5b3c, #4e3020);
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
}

.item-use-btn:disabled {
    opacity: 0.4;
    cursor: not-allowed;
}

.item-modal-footer {
    padding: 1.5vh 2vw;
    background: rgba(0, 0, 0, 0.5);
    border-top: 1px solid rgba(255, 255, 255, 0.15);
    text-align: center;
    flex-shrink: 0;
}

.item-close-btn {
    padding: 1vh 5vw;
    background: linear-gradient(135deg, #444, #222);
    color: #ddd;
    border: 1px solid #666;
    border-radius: 0.5vw;
    font-size: clamp(0.8rem, 2vw, 1.1rem);
    font-family: 'Ma Shan Zheng', cursive;
    cursor: pointer;
    transition: all 0.15s ease;
}

.item-close-btn:hover {
    background: linear-gradient(135deg, #555, #333);
}

/* 道具使用提示样式 */
.item-used-hint {
    padding: 2vh 3vw;
    background: rgba(100, 60, 20, 0.9);
    border: 1px solid #ffd700;
    border-radius: 0.6vw;
    text-align: center;
    font-family: 'Ma Shan Zheng', cursive;
    font-size: clamp(0.9rem, 2.2vw, 1.2rem);
    color: #ffd700;
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
}

/* 横屏和小屏幕下的道具弹窗优化 */
@media (max-height: 500px) {
    .item-modal-header {
        padding: 0.8vh 2vw;
        font-size: clamp(0.8rem, 2vw, 1rem);
    }
    
    .item-list {
        padding: 0.8vh 2vw;
        gap: 0.8vh;
    }
    
    .item-row {
        padding: 0.6vh 2vw;
        max-height: 20vh;
    }
    
    .item-name {
        font-size: clamp(0.75rem, 1.8vw, 1rem);
    }
    
    .item-desc {
        font-size: clamp(0.55rem, 1.2vw, 0.75rem);
    }
    
    .item-use-btn {
        padding: 0.5vh 2vw;
        font-size: clamp(0.65rem, 1.5vw, 0.85rem);
    }
    
    .item-modal-footer {
        padding: 0.8vh 2vw;
    }
    
    .item-close-btn {
        padding: 0.6vh 4vw;
        font-size: clamp(0.7rem, 1.6vw, 0.9rem);
    }
}

/* 极小屏幕优化 */
@media (max-height: 400px) {
    .item-modal-header {
        padding: 0.5vh 1.5vw;
    }
    
    .item-list {
        padding: 0.5vh 1.5vw;
        gap: 0.5vh;
    }
    
    .item-row {
        padding: 0.4vh 1.5vw;
    }
    
    .item-info {
        gap: 0;
    }
    
    .item-modal-footer {
        padding: 0.5vh 1.5vw;
    }
}
.modal-actions .btn {
    min-width: clamp(90px, 20vw, 160px);
    padding: clamp(8px, 1.8vw, 12px) clamp(14px, 2.8vw, 22px);
    border-radius: clamp(6px, 1vw, 10px);
    border: 1px solid rgba(255,255,255,0.25);
    font-family: 'Ma Shan Zheng', cursive;
    font-weight: bold;
    color: #fff;
    cursor: pointer;
    box-shadow: 0 4px 12px rgba(0,0,0,0.35);
    transition: transform .15s ease, box-shadow .2s ease, filter .2s ease;
}
.modal-actions .btn:hover { transform: translateY(-2px); filter: brightness(1.05); box-shadow: 0 8px 18px rgba(0,0,0,0.45); }
.modal-actions .btn:active { transform: translateY(0); }
.modal-actions .btn.btn-cancel { background: linear-gradient(135deg, #2b2b2b 0%, #1a1a1a 100%); border-color: #555; }
.modal-actions .btn.btn-danger { background: linear-gradient(135deg, #C62828 0%, #8E0000 100%); border-color: #ff6b6b; }
.modal-actions .btn.btn-danger:hover { box-shadow: 0 8px 20px rgba(198,40,40,0.5); }

</style>
</head>
<body>
    <div class="game-container">
        <!-- 主角图层 -->
        <div class="player-portrait-layer"></div>
        <!-- NPC图层 -->
        <div class="npc-portrait-layer"></div>
        <div class="screen-flash"></div>
        <!-- 战斗场景 -->
        <div class="battle-scene">
 
            <!-- 玩家状态区 -->
            <div class="player-status-area">
                <div class="name-row">
                    <div class="character-name" id="player-name">user</div>
                    <div class="taunt-status" id="player-taunt-status">挑衅中</div>
                </div>
                <div class="stats-row">
                    <div class="health-container">
                        <div class="health-bar">
                            <div class="health-fill" id="player-health"></div>
                            <div class="health-text">
                                <span id="player-health-value">50</span>/<span id="player-max-health">50</span>
                            </div>
                        </div>
                    </div>
                    <div class="energy-display">
                        <div class="energy-value">气:<span id="player-energy">0</span></div>
                    </div>
                </div>
            </div>

            <!-- 敌人状态区 -->
            <div class="enemy-status-area">
                <div class="name-row">
                    <div class="character-name" id="enemy-name">北条</div>
                    <div class="taunt-status" id="enemy-taunt-status">挑衅中</div>
                </div>
                <div class="stats-row">
                    <div class="health-container">
                        <div class="health-bar">
                            <div class="health-fill" id="enemy-health"></div>
                            <div class="health-text">
                                <span id="enemy-health-value">50</span>/<span id="enemy-max-health">50</span>
                            </div>
                        </div>
                    </div>
                    <div class="energy-display">
                        <div class="energy-value">气:<span id="enemy-energy">0</span></div>
                    </div>
                </div>
            </div>

            <!-- 回合指示器（点击显示日志） -->
            <div class="turn-indicator" id="turn-indicator" onclick="toggleLogDropdown()">
                <div id="turn-text">第1回合</div>
                <!-- 日志下拉框 -->
                <div class="log-dropdown" id="log-dropdown">
                    <p>战斗开始，请选择行动...</p>
                </div>
            </div>

            <!-- 左侧玩家角色 -->
            <div class="character player-character"></div>

            <!-- 右侧敌方角色 -->
            <div class="character enemy-character"></div>

            <!-- 战斗命令区域 -->
            <div class="command-buttons-floating">
                <div class="command-btn" id="gather" data-key="Q">
                    <div class="key-hint">Q</div>
                    <div class="btn-name">集气</div>
                </div>
                <div class="command-btn" id="defend" data-key="W">
                    <div class="key-hint">W</div>
                    <div class="btn-name">防御</div>
                </div>
                <div class="command-btn" id="light-attack" data-key="E">
                    <div class="key-hint">E</div>
                    <div class="btn-name">轻击</div>
                </div>
                <div class="command-btn" id="heavy-attack" data-key="R">
                    <div class="key-hint">R</div>
                    <div class="btn-name">重击</div>
                </div>
                <div class="command-btn" id="special" data-key="T">
                    <div class="key-hint">T</div>
                    <div class="btn-name">绝招</div>
                </div>
                <div class="command-btn" id="taunt" data-key="Y">
                    <div class="key-hint">Y</div>
                    <div class="btn-name">嘴炮</div>
                </div>
                <div class="command-btn" id="item" data-key="U">
                    <div class="key-hint">U</div>
                    <div class="btn-name">道具</div>
                </div>
                <div class="command-btn escape-btn" id="escape" data-key="Escape">
                    <div class="key-hint">Esc</div>
                    <div class="btn-name">逃跑</div>
                </div>
            </div>
        </div>

        <!-- 战斗日志（隐藏，数据保留用于下拉框同步） -->
        <div class="battle-log" id="battle-log">
            <p>战斗开始，请选择行动...</p>
        </div>
        
        <!-- 确认弹窗 -->
        <div id="confirm-modal" class="modal">
            <div class="modal-content">
                <div class="modal-header">确认行动</div>
                <div class="modal-body" id="confirm-body">
                    你确定要执行此操作吗？
                    <div id="selected-action" style="margin-top:8px;"></div>
                </div>
                <div class="modal-actions">
                    <button id="cancel-action" class="btn btn-cancel">返回战斗</button>
                    <button id="confirm-action" class="btn btn-danger">确认行动</button>
                 </div>
             </div>
         </div>

        <!-- 退出战斗确认（全屏固定） -->
        <div id="exit-battle-overlay" class="modal" style="z-index:1000;">
            <div class="modal-content">
                <div class="modal-header">确认退出</div>
                <div class="modal-body">确定要退出战斗吗？</div>
                <div class="modal-actions">
                    <button class="btn btn-cancel" onclick="document.getElementById('exit-battle-overlay').style.display='none'">返回战斗</button>
                    <button class="btn btn-danger" onclick="exitBattle('quit')">确认退出</button>
                 </div>
             </div>
         </div>

        <!-- 游戏结束弹窗 -->
        <div id="game-over-modal" class="modal">
            <div class="modal-content">
                <div class="modal-header" id="game-over-title">游戏结束</div>
                <div class="modal-body" id="game-over-message">
                    游戏结束信息
                </div>
                <div class="modal-footer" id="game-over-footer">
                    <button id="restart-game">重新开始</button>
                </div>
            </div>
        </div>

        <!-- 道具选择弹窗 -->
        <div id="item-modal" class="modal">
            <div class="item-modal-content">
                <div class="item-modal-header">选择道具</div>
                <div class="item-list" id="item-list">
                    <!-- 道具列表将由JavaScript动态生成 -->
                </div>
                <div class="item-modal-footer">
                    <button class="item-close-btn" onclick="closeItemModal()">返回战斗</button>
                </div>
            </div>
        </div>
    </div>
    <script>
// //回合制系统集成更新 - 获取URL参数
const urlParams = new URLSearchParams(window.location.search);

// 敌人类别列表（用于模糊匹配）
const ENEMY_CATEGORIES = ['正派弟子', '反派弟子', '游侠', '军士', '匪徒', '平民', '蒙面人', '野兽', '未知'];

// 类别同义词映射（用于模糊匹配）
const CATEGORY_SYNONYMS = {
    '门派弟子': '正派弟子',
    '武林弟子': '正派弟子',
    '正道弟子': '正派弟子',
    '魔教弟子': '反派弟子',
    '邪道弟子': '反派弟子',
    '邪派弟子': '反派弟子',
    '魔道弟子': '反派弟子',
    '侠客': '游侠',
    '江湖人': '游侠',
    '武者': '游侠',
    '士兵': '军士',
    '官兵': '军士',
    '守卫': '军士',
    '土匪': '匪徒',
    '盗贼': '匪徒',
    '强盗': '匪徒',
    '山贼': '匪徒',
    '马贼': '匪徒',
    '百姓': '平民',
    '村民': '平民',
    '商人': '平民',
    '路人': '平民',
    '刺客': '蒙面人',
    '黑衣人': '蒙面人',
    '神秘人': '蒙面人',
    '猛兽': '野兽',
    '野狼': '野兽',
    '猛虎': '野兽',
    '毒蛇': '野兽',
    '动物': '野兽',
    '怪物': '野兽'
};

// 道具系统变量
const battleItems = {
    daliwan: parseInt(urlParams.get('daliwan')) || 0,      // 大力丸
    jingutie: parseInt(urlParams.get('jingutie')) || 0,    // 筋骨贴
    jinchuangyao: parseInt(urlParams.get('jinchuangyao')) || 0,  // 金疮药
    piliwan: parseInt(urlParams.get('piliwan')) || 0       // 霹雳丸
};

// 道具使用状态
let itemUsedThisBattle = false;  // 本场战斗是否已使用道具
let usedItemKey = null;          // 使用的道具类型
let damageMultiplier = 1.0;      // 伤害倍率（大力丸效果）
let defenseMultiplier = 1.0;     // 防御倍率（筋骨贴效果）

// 道具配置
const itemConfig = {
    daliwan: {
        name: '大力丸',
        desc: '本场战斗所有伤害×1.25',
        effect: () => {
            damageMultiplier = 1.25;
            addLog('【道具】服用大力丸，攻击力大增！');
        }
    },
    jingutie: {
        name: '筋骨贴',
        desc: '本场战斗所受伤害÷1.25',
        effect: () => {
            defenseMultiplier = 1.25;
            addLog('【道具】贴上筋骨贴，防御力提升！');
        }
    },
    jinchuangyao: {
        name: '金疮药',
        desc: '立即恢复30%最大生命值',
        effect: () => {
            const healAmount = Math.round(gameState.player.maxHealth * 0.3);
            gameState.player.currentHealth = Math.min(
                gameState.player.currentHealth + healAmount,
                gameState.player.maxHealth
            );
            addLog(`【道具】使用金疮药，恢复${healAmount}点生命！`);
            updateDisplay();
        }
    },
    piliwan: {
        name: '霹雳丸',
        desc: '立即对敌人造成1.5倍攻击伤害',
        effect: () => {
            const damage = Math.round(gameState.player.basicDamage * 1.5);
            gameState.enemy.currentHealth -= damage;
            if (gameState.enemy.currentHealth < 0) gameState.enemy.currentHealth = 0;
            addLog(`【道具】投掷霹雳丸，对${gameState.enemy.name}造成${damage}点伤害！`);
            
            // 触发敌人受击动画
            const npcPortraitLayer = document.querySelector('.npc-portrait-layer');
            npcPortraitLayer.classList.add('shake');
            setTimeout(() => {
                npcPortraitLayer.classList.remove('shake');
            }, 400);
            
            updateDisplay();
            
            // 检查是否击杀敌人
            if (gameState.enemy.currentHealth <= 0) {
                setTimeout(() => {
                    checkGameOver();
                }, 500);
            }
        }
    }
};

// //回合制系统集成更新 - 玩家信息从URL参数获取
const PLAYER_INFO = {
    name: urlParams.get('playerName') || '你',
    maxHealth: parseInt(urlParams.get('playerHealth')) || 51,
    currentHealth: parseInt(urlParams.get('playerHealth')) || 51,
    energy: 0,
    maxEnergy: 10,
    selectedAction: null,
    basicDamage: parseInt(urlParams.get('playerAttack')) || 20,
    tauntedTurns: 0  // 挑衅状态剩余回合数
};

// //回合制系统集成更新 - 构建敌方信息文本
const enemyInfoText = `
发起战斗，敌方信息如下
name: ${urlParams.get('enemyName') || '钱塘君'}
  maxHealth: ${urlParams.get('enemyMaxHealth') || '极低'}
  basicDamage: ${urlParams.get('enemyBasicDamage') || '极低'}
`;

// 游戏主背景和弹窗背景图片链接
const GAME_BG_URL = urlParams.get('backgroundUrl') || 'https://cdn.jsdelivr.net/gh/Ji-Haitang/char_card_1@main/img/location/后山_昼.webp';
const MODAL_BG_URL = 'https://files.catbox.moe/jabi3y.jpg';


// 生命值和伤害等级映射
const healthMap = { '极低': 25,'低': 50, '中':100, '高': 175, '极高': 275 };
const damageMap = { '极低': 10,'低': 20, '中': 40, '高': 70, '极高': 120 };
const styles = ['风', '火', '林', '山'];

// 模糊匹配函数 - 计算编辑距离
function levenshteinDistance(a, b) {
    if (!a || !b) return Math.max((a || '').length, (b || '').length);
    if (a === b) return 0;
    
    const matrix = [];
    const aLen = a.length;
    const bLen = b.length;
    
    for (let i = 0; i <= bLen; i++) {
        matrix[i] = [i];
    }
    for (let j = 0; j <= aLen; j++) {
        matrix[0][j] = j;
    }
    
    for (let i = 1; i <= bLen; i++) {
        for (let j = 1; j <= aLen; j++) {
            if (b.charAt(i - 1) === a.charAt(j - 1)) {
                matrix[i][j] = matrix[i - 1][j - 1];
            } else {
                matrix[i][j] = Math.min(
                    matrix[i - 1][j - 1] + 1,
                    matrix[i][j - 1] + 1,
                    matrix[i - 1][j] + 1
                );
            }
        }
    }
    
    return matrix[bLen][aLen];
}

// 模糊匹配类别
function fuzzyMatchCategory(input) {
    if (!input || typeof input !== 'string') return '未知';
    
    const normalizedInput = input.trim();
    if (!normalizedInput) return '未知';
    
    // 1. 精确匹配
    if (ENEMY_CATEGORIES.includes(normalizedInput)) {
        return normalizedInput;
    }
    
    // 2. 同义词精确匹配
    if (CATEGORY_SYNONYMS[normalizedInput]) {
        const synonym = CATEGORY_SYNONYMS[normalizedInput];
        if (ENEMY_CATEGORIES.includes(synonym)) {
            console.log(`[类别匹配] 同义词匹配: "${normalizedInput}" -> "${synonym}"`);
            return synonym;
        }
    }
    
    // 3. 包含匹配
    for (const category of ENEMY_CATEGORIES) {
        if (normalizedInput.includes(category) || category.includes(normalizedInput)) {
            console.log(`[类别匹配] 包含匹配: "${normalizedInput}" -> "${category}"`);
            return category;
        }
    }
    
    // 4. 同义词的包含匹配
    for (const [key, value] of Object.entries(CATEGORY_SYNONYMS)) {
        if (normalizedInput.includes(key) || key.includes(normalizedInput)) {
            if (ENEMY_CATEGORIES.includes(value)) {
                console.log(`[类别匹配] 同义词包含匹配: "${normalizedInput}" (via "${key}") -> "${value}"`);
                return value;
            }
        }
    }
    
    // 5. 编辑距离匹配
    let bestMatch = '未知';
    let bestDistance = Infinity;
    const threshold = 2; // 允许的最大编辑距离
    
    for (const category of ENEMY_CATEGORIES) {
        const distance = levenshteinDistance(normalizedInput, category);
        if (distance < bestDistance && distance <= threshold) {
            bestDistance = distance;
            bestMatch = category;
        }
    }
    
    if (bestMatch !== '未知') {
        console.log(`[类别匹配] 编辑距离匹配: "${normalizedInput}" -> "${bestMatch}" (距离: ${bestDistance})`);
    } else {
        console.log(`[类别匹配] 无法匹配: "${normalizedInput}"，使用默认值"未知"`);
    }
    
    return bestMatch;
}

// 加权随机选择函数
function weightedRandom(options, debugInfo = null) {
    // options: { 'action': weight, ... }
    const entries = Object.entries(options);
    const totalWeight = entries.reduce((sum, [, weight]) => sum + weight, 0);
    const rollValue = Math.random() * totalWeight;
    let remaining = rollValue;
    
    // 如果需要调试输出
    if (debugInfo) {
        const actionNames = {
            'gather': '集气',
            'defend': '防御',
            'light-attack': '轻攻击',
            'heavy-attack': '重攻击',
            'special': '绝招',
            'taunt': '嘴炮'
        };
        const probabilities = entries.map(([action, weight]) => {
            const probability = (weight / totalWeight * 100).toFixed(1);
            return `${actionNames[action] || action}(${probability}%)`;
        });
        console.log(`[AI策略] 风格: ${debugInfo.style}, 能量范围: ${debugInfo.energyKey}`);
        console.log(`[AI策略] 参与加权的行动: ${probabilities.join(', ')}`);
        console.log(`[AI策略] Roll点: ${rollValue.toFixed(2)} / ${totalWeight} (${(rollValue / totalWeight * 100).toFixed(1)}%)`);
    }
    
    for (const [action, weight] of entries) {
        remaining -= weight;
        if (remaining <= 0) {
            if (debugInfo) {
                const actionNames = {
                    'gather': '集气',
                    'defend': '防御',
                    'light-attack': '轻攻击',
                    'heavy-attack': '重攻击',
                    'special': '绝招',
                    'taunt': '嘴炮'
                };
                console.log(`[AI策略] 选择结果: ${actionNames[action] || action}`);
            }
            return action;
        }
    }
    // 兜底返回第一个选项
    if (debugInfo) {
        console.log(`[AI策略] 选择结果(兜底): ${entries[0][0]}`);
    }
    return entries[0][0];
}

// 风格策略配置：基于能量范围的概率分布
const STYLE_STRATEGIES = {
    '风': {
        // 风格：快攻型，偏好轻攻击和嘴炮破防
        0: { 'gather': 100},
        1: { 'gather': 25, 'taunt': 30, 'light-attack': 45 },
        '2-4': { 'gather': 10, 'taunt': 25, 'light-attack': 45, 'heavy-attack': 20 },
        '5+': { 'gather': 10, 'taunt': 5, 'light-attack': 30, 'heavy-attack': 20, 'special': 35 }
    },
    '火': {
        // 火格：爆发型，偏好重攻击
        0: { 'gather': 100},
        1: { 'gather': 50, 'taunt': 15, 'light-attack': 35 },
        '2-4': { 'gather': 20, 'taunt': 5, 'light-attack': 20, 'heavy-attack': 55 },
        '5+': { 'gather': 10, 'taunt': 5, 'light-attack': 10, 'heavy-attack': 35, 'special': 40 }
    },
    '林': {
        // 林格：蓄力型，偏好集气和绝招
        0: { 'gather': 100},
        1: { 'gather': 75, 'taunt': 10, 'light-attack': 15 },
        '2-4': { 'gather': 60, 'taunt': 10, 'light-attack': 15, 'heavy-attack': 15 },
        '5+': { 'gather': 10, 'taunt': 5, 'light-attack': 10, 'heavy-attack': 15, 'special': 60}
    },
    '山': {
        // 山格：防守型（防御在独立阶段处理）
        0: { 'gather': 100},
        1: { 'gather': 50, 'taunt': 10, 'light-attack': 40 },
        '2-4': { 'gather': 50, 'taunt': 5, 'light-attack': 20, 'heavy-attack': 25 },
        '5+': { 'gather': 10, 'taunt': 5, 'light-attack': 15, 'heavy-attack': 20, 'special': 50 }
    }
};

// 根据能量获取对应的策略配置
function getEnergyRangeKey(energy) {
    if (energy === 0) return 0;
    if (energy === 1) return 1;
    if (energy >= 2 && energy <= 4) return '2-4';
    return '5+';
}

// 特殊NPC信息
const commonNPCs = {
    '破阵子': {
        name: '破阵子',
        maxHealth: 200,
        basicDamage: 140,
        style: '火',
        portrait: 'https://cdn.jsdelivr.net/gh/Ji-Haitang/char_card_1@main/img/NPC/破阵子.png'
    },
    '洞庭君': {
        name: '洞庭君',
        maxHealth: 275,
        basicDamage: 100,
        style: '林',
        portrait: 'https://cdn.jsdelivr.net/gh/Ji-Haitang/char_card_1@main/img/NPC/洞庭君.png'
    },
    '苓雪妃': {
        name: '苓雪妃',
        maxHealth: 250,
        basicDamage: 160,
        style: '风',
        portrait: 'https://cdn.jsdelivr.net/gh/Ji-Haitang/char_card_1@main/img/NPC/苓雪妃.png'
    },    
    '玄天青': {
        name: '玄天青',
        maxHealth: 300,
        basicDamage: 60,
        style: '山',
        portrait: 'https://cdn.jsdelivr.net/gh/Ji-Haitang/char_card_1@main/img/NPC/玄天青.png'
    },
    '钱塘君': {
        name: '钱塘君',
        maxHealth: 150,
        basicDamage: 100,
        style: '火',
        portrait: 'https://cdn.jsdelivr.net/gh/Ji-Haitang/char_card_1@main/img/NPC/钱塘君.png'
    },
    '萧白瑚': {
        name: '萧白瑚',
        maxHealth: 125,
        basicDamage: 60,
        style: '风',
        portrait: 'https://cdn.jsdelivr.net/gh/Ji-Haitang/char_card_1@main/img/NPC/萧白瑚.png'
    },
    '姬姒': {
        name: '姬姒',
        maxHealth: 350,
        basicDamage: 70,
        style: '山',
        portrait: 'https://cdn.jsdelivr.net/gh/Ji-Haitang/char_card_1@main/img/NPC/姬姒.png'
    },
    '施延年': {
        name: '施延年',
        maxHealth: 200,
        basicDamage: 50,
        style: '山',
        portrait: 'https://cdn.jsdelivr.net/gh/Ji-Haitang/char_card_1@main/img/NPC/施延年.png'
    },
    '呼延显': {
        name: '呼延显',
        maxHealth: 200,
        basicDamage: 100,
        style: '林',
        portrait: 'https://cdn.jsdelivr.net/gh/Ji-Haitang/char_card_1@main/img/NPC/呼延显.png'
    },
    '雨烛': {
        name: '雨烛',
        maxHealth: 100,
        basicDamage: 90,
        style: '风',
        portrait: 'https://cdn.jsdelivr.net/gh/Ji-Haitang/char_card_1@main/img/NPC/雨烛.png'
    },
    '安慕': {
        name: '安慕',
        maxHealth: 75,
        basicDamage: 110,
        style: '火',
        portrait: 'https://cdn.jsdelivr.net/gh/Ji-Haitang/char_card_1@main/img/NPC/安慕.png'
    },
    '唐沐梨': {
        name: '唐沐梨',
        maxHealth: 175,
        basicDamage: 80,
        style: '风',
        portrait: 'https://cdn.jsdelivr.net/gh/Ji-Haitang/char_card_1@main/img/NPC/唐沐梨.png'
    },
    '洛潜幽': {
        name: '洛潜幽',
        maxHealth: 50,
        basicDamage: 20,
        style: '山',
        portrait: 'https://cdn.jsdelivr.net/gh/Ji-Haitang/char_card_1@main/img/NPC/洛潜幽.png'
    },
    '神秘杂役': {
        name: '神秘杂役',
        maxHealth: 75,
        basicDamage: 300,
        style: '风',
        portrait: 'https://cdn.jsdelivr.net/gh/Ji-Haitang/char_card_1@main/img/NPC/神秘杂役.png'
    },
    '鹿椿若': {
        name: '鹿椿若',
        maxHealth: 150,
        basicDamage: 30,
        style: '林',
        portrait: 'https://cdn.jsdelivr.net/gh/Ji-Haitang/char_card_1@main/img/NPC/鹿椿若.png'
    }
};

const genericNPCPortraits = [
    'https://cdn.jsdelivr.net/gh/Ji-Haitang/char_card_1@main/img/NPC/杂鱼1.png',  // 占位链接1
    'https://cdn.jsdelivr.net/gh/Ji-Haitang/char_card_1@main/img/NPC/杂鱼2.png',  // 占位链接2
    'https://cdn.jsdelivr.net/gh/Ji-Haitang/char_card_1@main/img/NPC/杂鱼3.png'   // 占位链接3
];

// 解析敌方信息的函数
function parseEnemyInfo(text) {
    // 提取名称
    const nameMatch = text.match(/name:\s*([^\n]+)/);
    const npcName = nameMatch ? nameMatch[1].trim() : '';
    clearEnemyPortrait();
    
    // 获取难度参数
    const currentDifficulty = urlParams.get('difficulty') || 'normal';
    
    // 获取类别参数并进行模糊匹配
    const rawCategory = urlParams.get('enemyCategory') || '未知';
    const enemyCategory = fuzzyMatchCategory(rawCategory);
    console.log(`[敌人信息] 原始类别: "${rawCategory}" -> 匹配结果: "${enemyCategory}"`);
    
    // 优先查找常见NPC
    if (npcName && commonNPCs[npcName]) {
        const npc = commonNPCs[npcName];
        // 更新敌人立绘 - 使用战斗差分目录
        const npcBattlePortrait = `https://cdn.jsdelivr.net/gh/Ji-Haitang/char_card_1@main/img/战斗差分/${npc.name}-待机.png`;
        updateEnemyPortrait(npcBattlePortrait);
        
        // 根据难度调整属性
        let maxHealth = npc.maxHealth;
        let basicDamage = npc.basicDamage;
        
        if (currentDifficulty === 'normal') {
            maxHealth = Math.round(maxHealth * 1.25);
            basicDamage = Math.round(basicDamage * 1.25);
        } else if (currentDifficulty === 'hard') {
            maxHealth = Math.round(maxHealth * 1.5);
            basicDamage = Math.round(basicDamage * 1.5);
        }
        
        return {
            name: npc.name,
            maxHealth: maxHealth,
            currentHealth: maxHealth,
            energy: 0,
            maxEnergy: 10,
            selectedAction: null,
            basicDamage: basicDamage,
            style: npc.style,
            category: enemyCategory,  // 添加类别字段
            tauntedTurns: 0  // 挑衅状态剩余回合数
        };
    }

    // 没有匹配到常见NPC，根据类别选择立绘
    const categoryPortrait = getCategoryPortrait(enemyCategory);
    updateEnemyPortrait(categoryPortrait);
    
    // 走原有解析逻辑，风格随机
    const maxHealthMatch = text.match(/maxHealth:\s*([^\n]+)/);
    const basicDamageMatch = text.match(/basicDamage:\s*([^\n]+)/);
    
    let baseHealth = maxHealthMatch ? healthMap[maxHealthMatch[1].trim()] || 80 : 80;
    let baseDamage = basicDamageMatch ? damageMap[basicDamageMatch[1].trim()] || 30 : 30;
    
    // 根据难度调整属性
    if (currentDifficulty === 'normal') {
        baseHealth = Math.round(baseHealth * 1.25);
        baseDamage = Math.round(baseDamage * 1.25);
    } else if (currentDifficulty === 'hard') {
        baseHealth = Math.round(baseHealth * 1.5);
        baseDamage = Math.round(baseDamage * 1.5);
    }
    
    return {
        name: npcName,
        maxHealth: baseHealth,
        currentHealth: baseHealth,
        energy: 0,
        maxEnergy: 10,
        selectedAction: null,
        basicDamage: baseDamage,
        style: styles[Math.floor(Math.random() * styles.length)],
        category: enemyCategory,  // 添加类别字段
        tauntedTurns: 0  // 挑衅状态剩余回合数
    };
}

// 根据类别获取立绘
function getCategoryPortrait(category) {
    // 类别立绘映射 - 使用战斗差分目录下的待机图
    const categoryPortraits = {
        '正派弟子': 'https://cdn.jsdelivr.net/gh/Ji-Haitang/char_card_1@main/img/战斗差分/正派弟子-待机.png',
        '反派弟子': 'https://cdn.jsdelivr.net/gh/Ji-Haitang/char_card_1@main/img/战斗差分/反派弟子-待机.png',
        '游侠': 'https://cdn.jsdelivr.net/gh/Ji-Haitang/char_card_1@main/img/战斗差分/游侠-待机.png',
        '军士': 'https://cdn.jsdelivr.net/gh/Ji-Haitang/char_card_1@main/img/战斗差分/军士-待机.png',
        '匪徒': 'https://cdn.jsdelivr.net/gh/Ji-Haitang/char_card_1@main/img/战斗差分/匪徒-待机.png',
        '平民': 'https://cdn.jsdelivr.net/gh/Ji-Haitang/char_card_1@main/img/战斗差分/平民-待机.png',
        '蒙面人': 'https://cdn.jsdelivr.net/gh/Ji-Haitang/char_card_1@main/img/战斗差分/蒙面人-待机.png',
        '野兽': 'https://cdn.jsdelivr.net/gh/Ji-Haitang/char_card_1@main/img/战斗差分/野兽-待机.png',
        '未知': 'https://cdn.jsdelivr.net/gh/Ji-Haitang/char_card_1@main/img/战斗差分/未知-待机.png'
    };
    
    return categoryPortraits[category] || categoryPortraits['未知'];
}

// 更新敌人立绘
function updateEnemyPortrait(portraitUrl) {
    const npcPortraitLayer = document.querySelector('.npc-portrait-layer');
    npcPortraitLayer.style.backgroundImage = `url('${portraitUrl}')`;
}

// 清除敌人立绘
function clearEnemyPortrait() {
    const npcPortraitLayer = document.querySelector('.npc-portrait-layer');
    npcPortraitLayer.style.backgroundImage = '';
}

// 更新主角立绘
function updatePlayerPortrait(portraitUrl) {
    const playerPortraitLayer = document.querySelector('.player-portrait-layer');
    if (playerPortraitLayer) {
        playerPortraitLayer.style.backgroundImage = `url('${portraitUrl}')`;
    }
}

// 初始化主角立绘
function initPlayerPortrait() {
    const defaultPlayerPortrait = 'https://cdn.jsdelivr.net/gh/Ji-Haitang/char_card_1@main/img/战斗差分/主角-待机.png';
    updatePlayerPortrait(defaultPlayerPortrait);
}

// 获取主角立绘URL（根据状态）
function getPlayerPortraitUrl(state) {
    return `https://cdn.jsdelivr.net/gh/Ji-Haitang/char_card_1@main/img/战斗差分/主角-${state}.png`;
}

// 获取敌人立绘URL（根据状态）
function getEnemyPortraitUrl(state) {
    const enemy = gameState.enemy;
    const npcName = enemy.name;
    
    // 优先检查是否是特殊NPC
    if (npcName && commonNPCs[npcName]) {
        return `https://cdn.jsdelivr.net/gh/Ji-Haitang/char_card_1@main/img/战斗差分/${npcName}-${state}.png`;
    }
    
    // 否则使用类别
    const category = enemy.category || '未知';
    return `https://cdn.jsdelivr.net/gh/Ji-Haitang/char_card_1@main/img/战斗差分/${category}-${state}.png`;
}

// 设置立绘描边效果
function setPortraitGlow(isPlayer, glowColor) {
    const layer = isPlayer 
        ? document.querySelector('.player-portrait-layer')
        : document.querySelector('.npc-portrait-layer');
    
    if (!layer) return;
    
    // 清除所有描边效果
    layer.classList.remove('glow-yellow', 'glow-orange', 'glow-red');
    
    // 添加新的描边效果
    if (glowColor) {
        layer.classList.add(glowColor);
    }
}

// 切换立绘状态
function setPortraitState(isPlayer, state, glowColor) {
    if (isPlayer) {
        updatePlayerPortrait(getPlayerPortraitUrl(state));
    } else {
        updateEnemyPortrait(getEnemyPortraitUrl(state));
    }
    setPortraitGlow(isPlayer, glowColor);
}

// 恢复双方立绘到待机状态
function resetPortraitsToIdle() {
    setPortraitState(true, '待机', null);   // 玩家恢复待机
    setPortraitState(false, '待机', null);  // 敌人恢复待机
}

// 获取攻击类型对应的描边颜色类名
function getGlowClass(action, dealtDamage) {
    if (!dealtDamage) return null;
    switch(action) {
        case 'light-attack': return 'glow-yellow';  // 黄色
        case 'heavy-attack': return 'glow-orange';  // 橙色
        case 'special': return 'glow-red';          // 红色
        default: return null;
    }
}

// //回合制系统集成更新 - 退出战斗
function exitBattle(result) {
    // 向父窗口发送战斗结果和道具消耗信息
    if (window.parent !== window) {
        window.parent.postMessage({
            type: 'battle-exit',
            result: result, // 'victory' 或 'defeat' 或 'quit'
            itemUsed: usedItemKey,  // 使用的道具类型
            remainingItems: battleItems  // 剩余道具数量
        }, '*');
    }
}

// 打开道具弹窗
function openItemModal() {
    // 如果不是玩家回合或正在等待确认，返回
    if (gameState.currentTurn !== 'player' || gameState.waitingForConfirmation) return;
    
    const itemModal = document.getElementById('item-modal');
    const itemList = document.getElementById('item-list');
    
    // 清空列表
    itemList.innerHTML = '';
    
    // 如果本场战斗已使用道具，显示提示
    if (itemUsedThisBattle) {
        itemList.innerHTML = `
            <div class="item-used-hint">
                本场战斗已使用过道具，无法再次使用
            </div>
        `;
    } else {
        // 生成道具列表
        for (const [key, config] of Object.entries(itemConfig)) {
            const count = battleItems[key];
            const isEmpty = count <= 0;
            
            const itemRow = document.createElement('div');
            itemRow.className = `item-row${isEmpty ? ' disabled' : ''}`;
            itemRow.innerHTML = `
                <div class="item-info">
                    <div class="item-name">${config.name}</div>
                    <div class="item-desc">${config.desc}</div>
                </div>
                <div class="item-count${isEmpty ? ' empty' : ''}">×${count}</div>
                <button class="item-use-btn" ${isEmpty ? 'disabled' : ''} onclick="useItem('${key}')">使用</button>
            `;
            itemList.appendChild(itemRow);
        }
    }
    
    itemModal.style.display = 'flex';
}

// 关闭道具弹窗
function closeItemModal() {
    const itemModal = document.getElementById('item-modal');
    itemModal.style.display = 'none';
}

// 使用道具
function useItem(itemKey) {
    if (itemUsedThisBattle) {
        addLog('本场战斗已使用过道具！');
        return;
    }
    
    if (battleItems[itemKey] <= 0) {
        addLog('该道具数量不足！');
        return;
    }
    
    // 消耗道具
    battleItems[itemKey]--;
    itemUsedThisBattle = true;
    usedItemKey = itemKey;
    
    // 关闭弹窗
    closeItemModal();
    
    // 执行道具效果
    const config = itemConfig[itemKey];
    if (config && config.effect) {
        config.effect();
    }
    
    // 禁用道具按钮
    const itemBtn = document.getElementById('item');
    if (itemBtn) {
        itemBtn.classList.add('disabled');
    }
}

// //回合制系统集成更新 - 确认退出战斗
function confirmExitBattle() {
    const ov = document.getElementById('exit-battle-overlay');
    if (ov) { ov.style.display = 'flex'; }
}

const playerNameDisplay = document.getElementById('player-name');
const enemyNameDisplay = document.getElementById('enemy-name');
// 游戏状态对象
const gameState = {
    currentTurn: 'player',
    turnNumber: 1, // 添加回合计数器
    waitingForConfirmation: false,
    player: { ...PLAYER_INFO },
    enemy: parseEnemyInfo(enemyInfoText)
};

// 获取DOM元素
const playerHealthBar = document.getElementById('player-health');
const enemyHealthBar = document.getElementById('enemy-health');
const playerHealthValue = document.getElementById('player-health-value');
const enemyHealthValue = document.getElementById('enemy-health-value');
const playerMaxHealth = document.getElementById('player-max-health'); // 新增
const enemyMaxHealth = document.getElementById('enemy-max-health'); // 新增
const playerEnergyDisplay = document.getElementById('player-energy');
const enemyEnergyDisplay = document.getElementById('enemy-energy');
const battleLog = document.getElementById('battle-log');
const turnText = document.getElementById('turn-text');
const selectedActionText = document.getElementById('selected-action');
const confirmActionButton = document.getElementById('confirm-action');
const cancelActionButton = document.getElementById('cancel-action');
const commandButtons = document.querySelectorAll('.command-btn');
const confirmModal = document.getElementById('confirm-modal');
const gameOverModal = document.getElementById('game-over-modal');
const gameOverTitle = document.getElementById('game-over-title');
const gameOverMessage = document.getElementById('game-over-message');
const restartGameButton = document.getElementById('restart-game');

// 角色元素
const playerCharacter = document.querySelector('.player-character');
const enemyCharacter = document.querySelector('.enemy-character');

// 初始化游戏
function initGame() {
    // 初始化主角立绘
    initPlayerPortrait();
    
    updateDisplay();
    addLog('战斗开始，请选择行动...');
    
    // 添加按钮点击事件 - 支持触屏和鼠标
    setupButtonEvents();
    
    // 键盘控制
    document.addEventListener('keydown', handleKeyPress);
}

// 设置按钮事件
function setupButtonEvents() {
    document.getElementById('gather').addEventListener('click', () => selectAction('gather'));
    document.getElementById('defend').addEventListener('click', () => selectAction('defend'));
    document.getElementById('light-attack').addEventListener('click', () => selectAction('light-attack'));
    document.getElementById('heavy-attack').addEventListener('click', () => selectAction('heavy-attack'));
    document.getElementById('special').addEventListener('click', () => selectAction('special'));
    document.getElementById('taunt').addEventListener('click', () => selectAction('taunt'));
    document.getElementById('item').addEventListener('click', openItemModal);
    document.getElementById('escape').addEventListener('click', confirmExitBattle);
    
    // 确认按钮事件
    confirmActionButton.addEventListener('click', () => {
        if (confirmModal) confirmModal.style.display = 'none';
        confirmAction();
    });
    
    // 取消按钮事件
    cancelActionButton.addEventListener('click', () => {
        if (confirmModal) confirmModal.style.display = 'none';
        gameState.player.selectedAction = null;
        updateDisplay();
    });

    // //回合制系统集成更新 - 修改重新开始按钮的处理
    restartGameButton.addEventListener('click', () => {
        // 如果在iframe中，退出到父窗口
        if (window.parent !== window) {
            exitBattle('restart');
        } else {
            window.location.reload();
        }
    });
}

// 更新显示
function updateDisplay() {
    // 更新生命值显示
    playerHealthBar.style.width = `${(gameState.player.currentHealth / gameState.player.maxHealth) * 100}%`;
    enemyHealthBar.style.width = `${(gameState.enemy.currentHealth / gameState.enemy.maxHealth) * 100}%`;
    
    // 更新生命值文本
    playerHealthValue.textContent = gameState.player.currentHealth;
    enemyHealthValue.textContent = gameState.enemy.currentHealth;
    
    // 更新最大生命值文本
    playerMaxHealth.textContent = gameState.player.maxHealth;
    enemyMaxHealth.textContent = gameState.enemy.maxHealth;
    
    // 更新能量值
    playerEnergyDisplay.textContent = gameState.player.energy;
    enemyEnergyDisplay.textContent = gameState.enemy.energy;
    
    // 更新角色名字显示
    playerNameDisplay.textContent = gameState.player.name;
    enemyNameDisplay.textContent = gameState.enemy.name;
    
    // 根据敌人战斗风格设置名字颜色
    const styleColors = {
        '风': '#4169E1',  // 靛蓝色 (Royal Blue)
        '林': '#228B22',  // 深绿色 (Forest Green)
        '火': '#B22222',  // 暗红色 (Firebrick)
        '山': '#DAA520'   // 土黄色 (Goldenrod)
    };
    const enemyStyle = gameState.enemy.style;
    if (enemyStyle && styleColors[enemyStyle]) {
        enemyNameDisplay.style.color = styleColors[enemyStyle];
    }
    
    // 更新回合数显示
    turnText.textContent = `第${gameState.turnNumber}回合`;
    
    // 更新挑衅状态显示
    const playerTauntStatus = document.getElementById('player-taunt-status');
    const enemyTauntStatus = document.getElementById('enemy-taunt-status');
    
    if (gameState.player.tauntedTurns > 0) {
        playerTauntStatus.textContent = '挑衅中';
        playerTauntStatus.classList.add('active');
    } else {
        playerTauntStatus.classList.remove('active');
    }
    
    if (gameState.enemy.tauntedTurns > 0) {
        enemyTauntStatus.textContent = '挑衅中';
        enemyTauntStatus.classList.add('active');
    } else {
        enemyTauntStatus.classList.remove('active');
    }
    
    // 根据能量值启用/禁用按钮
    checkButtonAvailability();
}

// 检查按钮可用性
function checkButtonAvailability() {
    // 如果不是玩家回合或正在等待确认，禁用所有按钮
    if (gameState.currentTurn !== 'player' || gameState.waitingForConfirmation) {
        commandButtons.forEach(btn => {
            btn.classList.add('disabled');
        });
        return;
    }
    
    // 重置按钮状态
    commandButtons.forEach(btn => {
        btn.classList.remove('disabled');
        btn.classList.remove('selected');
    });
    
    // 根据能量值启用/禁用按钮
    if (gameState.player.energy < 1) {
        document.getElementById('light-attack').classList.add('disabled');
    }
    
    if (gameState.player.energy < 2) {
        document.getElementById('heavy-attack').classList.add('disabled');
    }
    
    if (gameState.player.energy < 5) {
        document.getElementById('special').classList.add('disabled');
    }
    
    // 挑衅状态下禁用防御
    if (gameState.player.tauntedTurns > 0) {
        document.getElementById('defend').classList.add('disabled');
    }
    
    // 本场战斗已使用道具则禁用道具按钮
    if (itemUsedThisBattle) {
        document.getElementById('item').classList.add('disabled');
    }
    
    // 如果有选中的动作，高亮显示
    if (gameState.player.selectedAction) {
        document.getElementById(gameState.player.selectedAction).classList.add('selected');
    }
}

// 添加战斗日志
function addLog(message) {
    const logEntry = document.createElement('p');
    logEntry.textContent = message;
    battleLog.appendChild(logEntry);
    battleLog.scrollTop = battleLog.scrollHeight;
    
    // 同步更新日志下拉框
    const logDropdown = document.getElementById('log-dropdown');
    if (logDropdown) {
        const dropdownEntry = document.createElement('p');
        dropdownEntry.textContent = message;
        logDropdown.appendChild(dropdownEntry);
        logDropdown.scrollTop = logDropdown.scrollHeight;
    }
}

// 切换日志下拉框显示
function toggleLogDropdown() {
    const logDropdown = document.getElementById('log-dropdown');
    if (logDropdown) {
        logDropdown.classList.toggle('active');
    }
}

// 点击其他区域关闭日志下拉框
document.addEventListener('click', function(e) {
    const turnIndicator = document.getElementById('turn-indicator');
    const logDropdown = document.getElementById('log-dropdown');
    if (turnIndicator && logDropdown && !turnIndicator.contains(e.target)) {
        logDropdown.classList.remove('active');
    }
});

// 选择动作
function selectAction(action) {
    // 如果不是玩家回合或正在等待确认，返回
    if (gameState.currentTurn !== 'player' || gameState.waitingForConfirmation) return;
    
    // 检查按钮是否被禁用
    if (document.getElementById(action).classList.contains('disabled')) {
        return;
    }
    
    // 清除之前的选择
    commandButtons.forEach(btn => btn.classList.remove('selected'));
    
    // 检查是否有足够的能量
    if ((action === 'light-attack' && gameState.player.energy < 1) ||
        (action === 'heavy-attack' && gameState.player.energy < 2) ||
        (action === 'special' && gameState.player.energy < 5)) {
        addLog('能量不足，无法执行此动作！');
        return;
    }
    
    // 设置选中状态
    document.getElementById(action).classList.add('selected');
    gameState.player.selectedAction = action;
    
    // 更新选择显示
    const actionNames = {
        'gather': '集气',
        'defend': '防御',
        'light-attack': '轻攻击',
        'heavy-attack': '重攻击',
        'special': '绝招',
        'taunt': '嘴炮'
    };
    selectedActionText.textContent = actionNames[action];
    
    // 显示确认弹窗
    confirmModal.style.display = 'flex';
}

// 确认动作
function confirmAction() {
    if (!gameState.player.selectedAction) return;
    
    // 设置为等待确认状态
    gameState.waitingForConfirmation = true;
    
    // 禁用按钮
    commandButtons.forEach(btn => {
        btn.classList.add('disabled');
    });
    
    addLog(`${gameState.player.name}准备行动...`);
    
    // 敌人AI选择动作
    selectEnemyAction();
    
    // 执行回合结算
    setTimeout(executeTurn, 1000);
}

// 敌人AI选择动作
function selectEnemyAction() {
    const enemy = gameState.enemy;
    const player = gameState.player;
    const style = enemy.style || '风'; // 默认风格
    
    // 检查是否处于挑衅状态（不能使用防御）
    const canDefend = enemy.tauntedTurns <= 0;

    // 玩家气的威胁等级
    const playerEnergy = player.energy;

    // 嘴炮判定：玩家气满5时，敌人有较高概率嘴炮
    if (playerEnergy >= 5) {
        if (style === '山' && Math.random() < 0.6) {
            enemy.selectedAction = 'taunt';
            return;
        }
        if (style === '林' && Math.random() < 0.5) {
            enemy.selectedAction = 'taunt';
            return;
        }
        if (style === '火' && Math.random() < 0.5) {
            enemy.selectedAction = 'taunt';
            return;
        }
        if (style === '风' && Math.random() < 0.4) {
            enemy.selectedAction = 'taunt';
            return;
        }
    }

    // 防御判定：玩家气较高时，敌人有概率防御（挑衅状态下不可防御）
    if (playerEnergy >= 1 && canDefend) {
        if (style === '山' && Math.random() < 0.5) {
            enemy.selectedAction = 'defend';
            return;
        }
        if (style === '林' && Math.random() < 0.3) {
            enemy.selectedAction = 'defend';
            return;
        }
        if (style === '火' && Math.random() < 0.25) {
            enemy.selectedAction = 'defend';
            return;
        }
        if (style === '风' && Math.random() < 0.25) {
            enemy.selectedAction = 'defend';
            return;
        }
    }

    // 风格主策略：基于能量范围的加权随机选择
    const styleStrategy = STYLE_STRATEGIES[style];
    if (styleStrategy) {
        const energyKey = getEnergyRangeKey(enemy.energy);
        const options = { ...styleStrategy[energyKey] };
        
        // 根据能量限制过滤不可用的行动
        if (enemy.energy < 1) {
            delete options['light-attack'];
        }
        if (enemy.energy < 2) {
            delete options['heavy-attack'];
        }
        if (enemy.energy < 5) {
            delete options['special'];
        }
        
        // 过滤掉无收益的嘴炮选项：玩家已被挑衅且气不足5时，嘴炮无收益
        if (player.tauntedTurns > 0 && playerEnergy < 5) {
            delete options['taunt'];
        }
        
        // 如果过滤后还有选项，使用加权随机选择
        if (Object.keys(options).length > 0) {
            const debugInfo = {
                style: style,
                energyKey: energyKey
            };
            enemy.selectedAction = weightedRandom(options, debugInfo);
            return;
        }
    }

    // 默认行为
    enemy.selectedAction = 'gather';
}

// 执行回合
function executeTurn() {
    const player = gameState.player;
    const enemy = gameState.enemy;
    
    // 获取双方行动
    const playerAction = player.selectedAction;
    const enemyAction = enemy.selectedAction;
    
    addLog(`${enemy.name}选择了行动...`);
    
    // 根据行动类型执行特效和结算
    setTimeout(() => {
        // 显示双方选择的动作
        const actionNames = {
            'gather': '集气',
            'defend': '防御',
            'light-attack': '轻攻击',
            'heavy-attack': '重攻击',
            'special': '绝招',
            'taunt': '嘴炮'
        };
        
        addLog(`${player.name}使用了${actionNames[playerAction]}！${enemy.name}使用了${actionNames[enemyAction]}！`);
        
        // 处理行动结果
        processActions(playerAction, enemyAction);
        
        // 检查游戏是否结束
        if (checkGameOver()) {
            return;
        }
        
        // 继续下一回合
        continueGame();
    }, 1000);
}

// 处理双方行动的结果
function processActions(playerAction, enemyAction) {
    const player = gameState.player;
    const enemy = gameState.enemy;
    const gameContainer = document.querySelector('.game-container');
    const npcPortraitLayer = document.querySelector('.npc-portrait-layer');
    const playerPortraitLayer = document.querySelector('.player-portrait-layer');
    const screenFlash = document.querySelector('.screen-flash');
    let playerWasHit = false;
    let enemyWasHit = false;
    
    // 立绘动画状态追踪
    let playerDealtDamage = false;      // 玩家是否造成伤害
    let enemyDealtDamage = false;       // 敌人是否造成伤害
    let playerSpecialBroken = false;    // 玩家绝招是否被嘴炮破
    let enemySpecialBroken = false;     // 敌人绝招是否被嘴炮破
    let playerDamageAction = null;      // 玩家造成伤害的攻击类型
    let enemyDamageAction = null;       // 敌人造成伤害的攻击类型
    let playerBrokenByTaunt = false;    // 玩家被嘴炮破防
    let enemyBrokenByTaunt = false;     // 敌人被嘴炮破防
    let playerHitBySpecial = false;     // 玩家被绝招无视防御
    let enemyHitBySpecial = false;      // 敌人被绝招无视防御
    
    // 处理集气
    if (playerAction === 'gather') {
        if (player.energy < player.maxEnergy) {
            player.energy += 1;
            addLog(`${player.name}集气成功，能量+1！`);
        } else {
            addLog(`${player.name}的能量已满！`);
        }
    }
    
    if (enemyAction === 'gather') {
        if (enemy.energy < enemy.maxEnergy) {
            enemy.energy += 1;
            addLog(`${enemy.name}集气成功，能量+1！`);
        } else {
            addLog(`${enemy.name}的能量已满！`);
        }
    }
    
    // 处理防御状态
    const playerDefending = playerAction === 'defend';
    const enemyDefending = enemyAction === 'defend';
    
    if (playerDefending) {
        playerCharacter.classList.add('player-defend');
        setTimeout(() => {
            playerCharacter.classList.remove('player-defend');
        }, 1000);
        addLog(`${player.name}进入防御状态！`);
    }
    
    if (enemyDefending) {
        enemyCharacter.classList.add('enemy-defend');
        setTimeout(() => {
            enemyCharacter.classList.remove('enemy-defend');
        }, 1000);
        addLog(`${enemy.name}进入防御状态！`);
    }
    
    // 嘴炮逻辑处理
    let playerTauntSuccess = false;
    let enemyTauntSuccess = false;
    
    // 双方同时嘴炮，无事发生
    if (playerAction === 'taunt' && enemyAction === 'taunt') {
        addLog('双方互相嘴炮，不分高下！');
    } else {
        // 嘴炮对防御的效果：挑衅
        if (playerAction === 'taunt' && enemyDefending) {
            // 玩家嘴炮 vs 敌人防御：敌人气-1，进入挑衅状态
            if (enemy.energy > 0) {
                enemy.energy -= 1;
                addLog(`${player.name}的嘴炮激怒了${enemy.name}！${enemy.name}气-1，进入挑衅状态！`);
            } else {
                addLog(`${player.name}的嘴炮激怒了${enemy.name}！${enemy.name}进入挑衅状态！`);
            }
            enemy.tauntedTurns = 3;
            enemyWasHit = true;
            enemyBrokenByTaunt = true;  // 敌人被嘴炮破防
        }
        
        if (enemyAction === 'taunt' && playerDefending) {
            // 敌人嘴炮 vs 玩家防御：玩家气-1，进入挑衅状态
            if (player.energy > 0) {
                player.energy -= 1;
                addLog(`${enemy.name}的嘴炮激怒了${player.name}！${player.name}气-1，进入挑衅状态！`);
            } else {
                addLog(`${enemy.name}的嘴炮激怒了${player.name}！${player.name}进入挑衅状态！`);
            }
            player.tauntedTurns = 3;
            playerWasHit = true;
            playerBrokenByTaunt = true;  // 玩家被嘴炮破防
        }
        
        // 嘴炮对绝招的效果：无效化伤害（保持原有逻辑）
        if (playerAction === 'taunt' && enemyAction === 'special') {
            playerTauntSuccess = true;
            enemySpecialBroken = true;  // 敌人绝招被破
            addLog(`${player.name}的嘴炮成功无效化了${enemy.name}的绝招伤害！`);
        }
        
        if (enemyAction === 'taunt' && playerAction === 'special') {
            enemyTauntSuccess = true;
            playerSpecialBroken = true;  // 玩家绝招被破
            addLog(`${enemy.name}的嘴炮成功无效化了${player.name}的绝招伤害！`);
        }
    }
    
    // 处理绝招（无视防御）
    if (playerAction === 'special') {
        // 无论绝招是否被嘴炮无效化，都消耗能量
        player.energy -= 5;
        playerCharacter.classList.add('player-special');
        
        if (!enemyTauntSuccess) {
            enemyCharacter.classList.add('enemy-hit');
            
            setTimeout(() => {
                enemyCharacter.classList.remove('enemy-hit');
            }, 1000);
            
            const damage = Math.round(player.basicDamage * 3 * damageMultiplier);
            enemy.currentHealth -= damage;
            addLog(`${player.name}使用绝招，对${enemy.name}造成${damage}点伤害！`);
            enemyWasHit = true;
            playerDealtDamage = true;           // 玩家造成伤害
            playerDamageAction = 'special';     // 记录攻击类型
            if (enemyDefending) {
                enemyHitBySpecial = true;       // 敌人防御被绝招无视
            }
        } else {
            addLog(`${player.name}使用绝招，但伤害被${enemy.name}的嘴炮无效化了！`);
        }
        
        setTimeout(() => {
            playerCharacter.classList.remove('player-special');
        }, 1000);
        
        // 无效化敌人的普通攻击
        if (enemyAction === 'light-attack' || enemyAction === 'heavy-attack') {
            addLog(`${enemy.name}的攻击被${player.name}的绝招无效化了！`);
            // 敌人消耗的能量不返还
            if (enemyAction === 'light-attack') enemy.energy -= 1;
            if (enemyAction === 'heavy-attack') enemy.energy -= 2;
        }
    }
    
    if (enemyAction === 'special') {
        // 无论绝招是否被嘴炮无效化，都消耗能量
        enemy.energy -= 5;
        enemyCharacter.classList.add('enemy-special');
        
        if (!playerTauntSuccess) {
            playerCharacter.classList.add('player-hit');
            
            setTimeout(() => {
                playerCharacter.classList.remove('player-hit');
            }, 1000);
            
            const damage = Math.round(enemy.basicDamage * 3 / defenseMultiplier);
            player.currentHealth -= damage;
            addLog(`${enemy.name}使用绝招，对${player.name}造成${damage}点伤害！`);
            playerWasHit = true;
            enemyDealtDamage = true;           // 敌人造成伤害
            enemyDamageAction = 'special';     // 记录攻击类型
            if (playerDefending) {
                playerHitBySpecial = true;     // 玩家防御被绝招无视
            }
        } else {
            addLog(`${enemy.name}使用绝招，但伤害被${player.name}的嘴炮无效化了！`);
        }
        
        setTimeout(() => {
            enemyCharacter.classList.remove('enemy-special');
        }, 1000);
        
        // 无效化玩家的普通攻击
        if (playerAction === 'light-attack' || playerAction === 'heavy-attack') {
            addLog(`${player.name}的攻击被${enemy.name}的绝招无效化了！`);
            // 玩家消耗的能量不返还
            if (playerAction === 'light-attack') player.energy -= 1;
            if (playerAction === 'heavy-attack') player.energy -= 2;
        }
    }
    
    // 如果没有被绝招无效，处理重攻击
    if (playerAction === 'heavy-attack' &&
        enemyAction !== 'special' &&
        playerAction !== 'special') {
        player.energy -= 2;
        
        // 检查是否被防御或是否无效对方轻攻击
        if (enemyDefending) {
            playerCharacter.classList.add('player-attack');
            // enemyCharacter.classList.add('enemy-hit');
            
            setTimeout(() => {
                playerCharacter.classList.remove('player-attack');
                // enemyCharacter.classList.remove('enemy-hit');
            }, 600);
            
            // 防御重攻击受到25%伤害
            const reducedDamage = Math.round(player.basicDamage * 1.5 * 0.25 * damageMultiplier);
            enemy.currentHealth -= reducedDamage;
            addLog(`${player.name}的重攻击被${enemy.name}防御了，但仍造成${reducedDamage}点伤害！`);
            enemyWasHit = true;
            playerDealtDamage = true;
            playerDamageAction = 'heavy-attack';
        } else if (enemyAction === 'light-attack') {
            // 重攻击克制轻攻击
            playerCharacter.classList.add('player-attack');
            enemyCharacter.classList.add('enemy-hit');
            
            setTimeout(() => {
                playerCharacter.classList.remove('player-attack');
                enemyCharacter.classList.remove('enemy-hit');
            }, 600);
            
            const damage = Math.round(player.basicDamage * 1.5 * damageMultiplier);
            enemy.currentHealth -= damage;
            enemy.energy -= 1; // 消耗敌人的能量
            addLog(`${player.name}的重攻击无效化了${enemy.name}的轻攻击，并造成${damage}点伤害！`);
            enemyWasHit = true;
            playerDealtDamage = true;
            playerDamageAction = 'heavy-attack';
        } else {
            playerCharacter.classList.add('player-attack');
            enemyCharacter.classList.add('enemy-hit');
            
            setTimeout(() => {
                playerCharacter.classList.remove('player-attack');
                enemyCharacter.classList.remove('enemy-hit');
            }, 600);
            
            const damage = Math.round(player.basicDamage * 1.5 * damageMultiplier);
            enemy.currentHealth -= damage;
            addLog(`${player.name}的重攻击对${enemy.name}造成${damage}点伤害！`);
            enemyWasHit = true;
            playerDealtDamage = true;
            playerDamageAction = 'heavy-attack';
        }
    }
    
    if (enemyAction === 'heavy-attack' &&
        playerAction !== 'special' &&
        enemyAction !== 'special') {
        enemy.energy -= 2;
        
        // 检查是否被防御或是否无效对方轻攻击
        if (playerDefending) {
            enemyCharacter.classList.add('enemy-attack');
            // playerCharacter.classList.add('player-hit');
            
            setTimeout(() => {
                enemyCharacter.classList.remove('enemy-attack');
                // playerCharacter.classList.remove('player-hit');
            }, 600);
            
            // 防御重攻击受到20%伤害
            const reducedDamage = Math.round(enemy.basicDamage * 1.5 * 0.2 / defenseMultiplier);
            player.currentHealth -= reducedDamage;
            addLog(`${enemy.name}的重攻击被${player.name}防御了，但仍造成${reducedDamage}点伤害！`);
            playerWasHit = true;
            enemyDealtDamage = true;
            enemyDamageAction = 'heavy-attack';
        } else if (playerAction === 'light-attack') {
            // 重攻击克制轻攻击
            enemyCharacter.classList.add('enemy-attack');
            playerCharacter.classList.add('player-hit');
            
            setTimeout(() => {
                enemyCharacter.classList.remove('enemy-attack');
                playerCharacter.classList.remove('player-hit');
            }, 600);
            
            const damage = Math.round(enemy.basicDamage * 1.5 / defenseMultiplier);
            player.currentHealth -= damage;
            player.energy -= 1; // 消耗玩家的能量
            addLog(`${enemy.name}的重攻击无效化了${player.name}的轻攻击，并造成${damage}点伤害！`);
            playerWasHit = true;
            enemyDealtDamage = true;
            enemyDamageAction = 'heavy-attack';
        } else {
            enemyCharacter.classList.add('enemy-attack');
            playerCharacter.classList.add('player-hit');
            
            setTimeout(() => {
                enemyCharacter.classList.remove('enemy-attack');
                playerCharacter.classList.remove('player-hit');
            }, 600);
            
            const damage = Math.round(enemy.basicDamage * 1.5 / defenseMultiplier);
            player.currentHealth -= damage;
            addLog(`${enemy.name}的重攻击对${player.name}造成${damage}点伤害！`);
            playerWasHit = true;
            enemyDealtDamage = true;
            enemyDamageAction = 'heavy-attack';
        }
    }
    
    // 如果没有被重攻击或绝招无效，处理轻攻击
    if (playerAction === 'light-attack' && 
        enemyAction !== 'heavy-attack' && 
        enemyAction !== 'special') {
        player.energy -= 1;
        
        // 检查是否被防御
        if (enemyDefending) {
            playerCharacter.classList.add('player-attack');
            // enemyCharacter.classList.add('enemy-hit');
            
            setTimeout(() => {
                playerCharacter.classList.remove('player-attack');
                // enemyCharacter.classList.remove('enemy-hit');
            }, 600);
            
            // 防御轻攻击受到15%伤害
            const reducedDamage = Math.round(player.basicDamage * 0.15 * damageMultiplier);
            enemy.currentHealth -= reducedDamage;
            addLog(`${player.name}的轻攻击被${enemy.name}防御了，但仍造成${reducedDamage}点伤害！`);
            enemyWasHit = true;
            playerDealtDamage = true;
            playerDamageAction = 'light-attack';
        } else {
            playerCharacter.classList.add('player-attack');
            enemyCharacter.classList.add('enemy-hit');
            
            setTimeout(() => {
                playerCharacter.classList.remove('player-attack');
                enemyCharacter.classList.remove('enemy-hit');
            }, 600);
            
            const damage = Math.round(player.basicDamage * damageMultiplier);
            enemy.currentHealth -= damage;
            addLog(`${player.name}的轻攻击对${enemy.name}造成${damage}点伤害！`);
            enemyWasHit = true;
            playerDealtDamage = true;
            playerDamageAction = 'light-attack';
        }
    }
    
    if (enemyAction === 'light-attack' && 
        playerAction !== 'heavy-attack' && 
        playerAction !== 'special') {
        enemy.energy -= 1;
        
        // 检查是否被防御
        if (playerDefending) {
            enemyCharacter.classList.add('enemy-attack');
            // playerCharacter.classList.add('player-hit');
            
            setTimeout(() => {
                enemyCharacter.classList.remove('enemy-attack');
                // playerCharacter.classList.remove('player-hit');
            }, 600);
            
            // 防御轻攻击受到15%伤害
            const reducedDamage = Math.round(enemy.basicDamage * 0.15 / defenseMultiplier);
            player.currentHealth -= reducedDamage;
            addLog(`${enemy.name}的轻攻击被${player.name}防御了，但仍造成${reducedDamage}点伤害！`);
            playerWasHit = true;
            enemyDealtDamage = true;
            enemyDamageAction = 'light-attack';
        } else {
            enemyCharacter.classList.add('enemy-attack');
            playerCharacter.classList.add('player-hit');
            
            setTimeout(() => {
                enemyCharacter.classList.remove('enemy-attack');
                playerCharacter.classList.remove('player-hit');
            }, 600);
            
            const damage = Math.round(enemy.basicDamage / defenseMultiplier);
            player.currentHealth -= damage;
            addLog(`${enemy.name}的轻攻击对${player.name}造成${damage}点伤害！`);
            playerWasHit = true;
            enemyDealtDamage = true;
            enemyDamageAction = 'light-attack';
        }
    }
    
    // 确保生命值不为负数
    if (player.currentHealth < 0) player.currentHealth = 0;
    if (enemy.currentHealth < 0) enemy.currentHealth = 0;
    
    // 受击反馈动画（与立绘受击状态判断一致）
    // 玩家真正受击的情况：绝招被破、被嘴炮破防、被绝招无视防御、非防御状态被打
    const playerTrueHit = playerSpecialBroken || playerBrokenByTaunt || playerHitBySpecial || (playerWasHit && !playerDefending);
    // 敌人真正受击的情况：绝招被破、被嘴炮破防、被绝招无视防御、非防御状态被打
    const enemyTrueHit = enemySpecialBroken || enemyBrokenByTaunt || enemyHitBySpecial || (enemyWasHit && !enemyDefending);
    
    if (playerTrueHit) {
        gameContainer.classList.add('shake');
        screenFlash.classList.add('active');
        playerPortraitLayer.classList.add('shake');
        setTimeout(() => {
            gameContainer.classList.remove('shake');
            screenFlash.classList.remove('active');
            playerPortraitLayer.classList.remove('shake');
        }, 400);
    }
    if (enemyTrueHit) {
        npcPortraitLayer.classList.add('shake');
        setTimeout(() => {
            npcPortraitLayer.classList.remove('shake');
        }, 400);
    }
    
    // ========== 立绘动画逻辑 ==========
    // 确定玩家立绘状态
    let playerPortraitState = '待机';
    let playerGlowClass = null;
    
    if (playerSpecialBroken) {
        // 绝招被嘴炮破，显示受击
        playerPortraitState = '受击';
    } else if (playerDealtDamage) {
        // 造成伤害优先显示攻击
        playerPortraitState = '攻击';
        playerGlowClass = getGlowClass(playerDamageAction, true);
    } else if (playerBrokenByTaunt || playerHitBySpecial) {
        // 被嘴炮破防或被绝招无视防御，显示受击
        playerPortraitState = '受击';
    } else if (playerDefending) {
        // 防御状态（正常防御轻/重攻击）
        playerPortraitState = '防御';
    } else if (playerWasHit) {
        // 只受伤显示受击（非防御情况下被打）
        playerPortraitState = '受击';
    }
    
    // 确定敌人立绘状态
    let enemyPortraitState = '待机';
    let enemyGlowClass = null;
    
    if (enemySpecialBroken) {
        // 绝招被嘴炮破，显示受击
        enemyPortraitState = '受击';
    } else if (enemyDealtDamage) {
        // 造成伤害优先显示攻击
        enemyPortraitState = '攻击';
        enemyGlowClass = getGlowClass(enemyDamageAction, true);
    } else if (enemyBrokenByTaunt || enemyHitBySpecial) {
        // 被嘴炮破防或被绝招无视防御，显示受击
        enemyPortraitState = '受击';
    } else if (enemyDefending) {
        // 防御状态（正常防御轻/重攻击）
        enemyPortraitState = '防御';
    } else if (enemyWasHit) {
        // 只受伤显示受击（非防御情况下被打）
        enemyPortraitState = '受击';
    }
    
    // 应用立绘状态
    setPortraitState(true, playerPortraitState, playerGlowClass);
    setPortraitState(false, enemyPortraitState, enemyGlowClass);
    
    // 1.0秒后恢复待机状态
    setTimeout(() => {
        resetPortraitsToIdle();
    }, 1000);
    
    // 更新显示
    updateDisplay();
}

// 继续游戏
function continueGame() {
    // 重置选择状态
    gameState.player.selectedAction = null;
    gameState.enemy.selectedAction = null;
    gameState.waitingForConfirmation = false;
    selectedActionText.textContent = '无';
    
    // 递减挑衅状态计数
    if (gameState.player.tauntedTurns > 0) {
        gameState.player.tauntedTurns--;
        if (gameState.player.tauntedTurns === 0) {
            addLog(`${gameState.player.name}的挑衅状态结束了。`);
        }
    }
    if (gameState.enemy.tauntedTurns > 0) {
        gameState.enemy.tauntedTurns--;
        if (gameState.enemy.tauntedTurns === 0) {
            addLog(`${gameState.enemy.name}的挑衅状态结束了。`);
        }
    }
    
    // 增加回合数
    gameState.turnNumber++;
    
    // 更新显示
    updateDisplay();
    
    // 继续游戏
    addLog('准备下一回合...');
    
    // 更新回合指示
    setTimeout(() => {
        addLog('请选择你的行动...');
    }, 1000);
}

// 检查游戏是否结束
function checkGameOver() {
    if (gameState.player.currentHealth <= 0) {
        addLog(`${gameState.player.name}被击败了！游戏结束。`);
        gameEnd(false);
        return true;
    } else if (gameState.enemy.currentHealth <= 0) {
        addLog(`${gameState.enemy.name}被击败了！胜利！`);
        gameEnd(true);
        return true;
    }
    return false;
}

// //回合制系统集成更新 - 游戏结束
function gameEnd(isVictory) {
    // 禁用所有按钮
    commandButtons.forEach(btn => {
        btn.classList.add('disabled');
    });
    
    // 获取角色名字
    const playerName = gameState.player.name;
    const enemyName = gameState.enemy.name;
    
    // 设置弹窗内容
    if (isVictory) {
        gameOverTitle.textContent = '战斗胜利';
        gameOverMessage.textContent = `${playerName}战胜了${enemyName}！`;
        addLog('恭喜你取得胜利！');
    } else {
        gameOverTitle.textContent = '战斗失败';
        gameOverMessage.textContent = `${playerName}败给了${enemyName}！`;
        addLog('游戏结束，再接再厉！');
    }
    
    // 检查是否在iframe中运行
    const isInIframe = window.parent !== window;
    
    if (isInIframe) {
        // 在iframe中，隐藏重新开始按钮和整个footer
        document.getElementById('game-over-footer').style.display = 'none';
        
        // 显示游戏结束弹窗
        gameOverModal.style.display = 'flex';
        
        // 3秒后自动退出（稍微延长一点时间让玩家看到结果）
        setTimeout(() => {
            exitBattle(isVictory ? 'victory' : 'defeat');
        }, 3000);
    } else {
        // 不在iframe中，显示重新开始按钮
        document.getElementById('game-over-footer').style.display = 'flex';
        
        // 显示游戏结束弹窗
        gameOverModal.style.display = 'flex';
    }
}


// 键盘事件处理
function handleKeyPress(event) {
    // 如果道具弹窗显示中，按ESC关闭
    const itemModal = document.getElementById('item-modal');
    if (itemModal && itemModal.style.display === 'flex' && event.key === 'Escape') {
        closeItemModal();
        return;
    }
    
    // 如果弹窗显示中，按ESC关闭
    if (confirmModal.style.display === 'flex' && event.key === 'Escape') {
        confirmModal.style.display = 'none'; gameState.player.selectedAction = null;
        updateDisplay(); return;
    }


    // 如果弹窗显示中，按Enter确认
    if (confirmModal.style.display === 'flex' && event.key === 'Enter') {
        confirmModal.style.display = 'none';
        confirmAction();
        return;
    }

    // 如果不是玩家回合或正在等待确认，返回
    if (gameState.currentTurn !== 'player' || gameState.waitingForConfirmation) return;

    const key = event.key.toUpperCase();

    switch (key) {
        case 'Q':
            selectAction('gather');
            break;
        case 'W':
            selectAction('defend');
            break;
        case 'E':
            selectAction('light-attack');
            break;
        case 'R':
            selectAction('heavy-attack');
            break;
        case 'T':
            selectAction('special');
            break;
        case 'Y':
            selectAction('taunt');
            break;
        case 'U':
            openItemModal();
            break;
    }
}

// 初始化游戏 
// 动态设置1.46比例的函数 
function setAspectRatio() { 
    const gameContainer = document.querySelector('.game-container'); 
    if (!gameContainer) return;

    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;

    // 计算1.46比例的尺寸（与主界面viewport一致）
    const aspectRatio = 1.46;
    let gameWidth, gameHeight;

    // 优先基于宽度计算（高度为宽度的 1/1.46 ≈ 0.685）
    gameWidth = viewportWidth;
    gameHeight = viewportWidth / aspectRatio;

    // 如果计算出的高度超过视口高度，则根据高度反推宽度
    if (gameHeight > viewportHeight) {
        gameHeight = viewportHeight;
        gameWidth = viewportHeight * aspectRatio;
    }

    // 确保不会超出边界
    gameWidth = Math.min(gameWidth, viewportWidth);
    gameHeight = Math.min(gameHeight, viewportHeight);

    // 应用尺寸
    gameContainer.style.width = `${gameWidth}px`;
    gameContainer.style.height = `${gameHeight}px`;
    
    // 确保容器紧贴顶部
    gameContainer.style.marginTop = '0';
    
    // 水平居中（如果宽度小于视口宽度）
    if (gameWidth < viewportWidth) {
        gameContainer.style.marginLeft = `${(viewportWidth - gameWidth) / 2}px`;
        gameContainer.style.marginRight = 'auto';
    } else {
        gameContainer.style.marginLeft = '0';
        gameContainer.style.marginRight = '0';
    }

    console.log(`游戏容器尺寸: ${gameWidth}x${gameHeight}, 视口: ${viewportWidth}x${viewportHeight}, 比例: ${(gameWidth/gameHeight).toFixed(2)}`);
}

// 窗口大小变化时重新设置比例 
function handleResize() { 
    setAspectRatio(); 
}

// 初始化尺寸设置 
function initAspectRatio() { 
    setAspectRatio();

    // 监听窗口大小变化
    window.addEventListener('resize', handleResize);
    window.addEventListener('orientationchange', () => {
        // 延迟执行，等待方向变化完成
        setTimeout(setAspectRatio, 100);
    });
}

// 修改原有的DOMContentLoaded事件监听 
document.addEventListener('DOMContentLoaded', () => { 
    // 首先设置4:3比例 
    initAspectRatio();

    // 设置主背景
    const gameContainer = document.querySelector('.game-container');
    if (gameContainer) {
        gameContainer.style.backgroundImage = `url('${GAME_BG_URL}')`;
    }

    // 设置弹窗背景 - 排除道具弹窗
    const modalContents = document.querySelectorAll('.modal-content');
    modalContents.forEach(modal => {
        modal.style.background = `url('${MODAL_BG_URL}') center center / cover`;
    });
    
    // 道具弹窗使用不透明纯色背景
    const itemModalContent = document.querySelector('.item-modal-content');
    if (itemModalContent) {
        itemModalContent.style.background = 'linear-gradient(135deg, #1a1410 0%, #2a2018 50%, #1a1410 100%)';
    }

    // 初始化游戏
    initGame();
});

    </script> 
</body> 
</html>
